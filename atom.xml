<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>男猿北蛰</title>
  
  <subtitle>CodePorter&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://balderdasher.github.io/"/>
  <updated>2021-09-29T08:09:49.224Z</updated>
  <id>https://balderdasher.github.io/</id>
  
  <author>
    <name>Code Porter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用hexo与GitHub搭建个人博客</title>
    <link href="https://balderdasher.github.io/2021/09/29/build-blog-with-hexo-vs-github/"/>
    <id>https://balderdasher.github.io/2021/09/29/build-blog-with-hexo-vs-github/</id>
    <published>2021-09-29T07:54:49.000Z</published>
    <updated>2021-09-29T08:09:49.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">https://blog.csdn.net/gdutxiaoxu/article/details/53576018</a></li><li><a href="https://www.zhihu.com/question/21193762/answer/134278844" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762/answer/134278844</a></li><li><a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">https://www.jianshu.com/p/f054333ac9e6</a></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="一-日常改动流程"><a href="#一-日常改动流程" class="headerlink" title="一.日常改动流程"></a>一.日常改动流程</h3><p>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：</p><ol><li>依次执行<code>git add .</code>、<code>git commit -m &quot;...&quot;</code>、<code>git push origin hexo</code>指令将改动推送到GitHub（此时当前分支应为hexo）</li><li>然后才执行<code>hexo g -d</code>发布网站到master分支上</li></ol><h3 id="一-换了电脑之后怎么办"><a href="#一-换了电脑之后怎么办" class="headerlink" title="一.换了电脑之后怎么办"></a>一.换了电脑之后怎么办</h3><ol><li>使用<code>git clone</code> 命令拉取GitHub仓库（默认分支为hexo）</li><li>在本地仓库文件夹下通过Git bash依次执行下列指令：<code>npm install hexo</code>、<code>npm install</code>、<code>npm install hexo-deployer-git</code>（记得，不需要<code>hexo init</code>这条指令）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/gdutxiaoxu/article/detail
      
    
    </summary>
    
      <category term="奇门遁甲" scheme="https://balderdasher.github.io/categories/%E5%A5%87%E9%97%A8%E9%81%81%E7%94%B2/"/>
    
    
      <category term="hexo" scheme="https://balderdasher.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>活生生地生活</title>
    <link href="https://balderdasher.github.io/2021/09/29/live-animatedly/"/>
    <id>https://balderdasher.github.io/2021/09/29/live-animatedly/</id>
    <published>2021-09-29T06:04:29.567Z</published>
    <updated>2021-09-29T06:04:29.567Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/9QAEkTc.jpg" alt><br><a id="more"></a></p><h2 id="岁月如梭"><a href="#岁月如梭" class="headerlink" title="岁月如梭"></a>岁月如梭</h2><p>岁月是把杀猪刀，转眼就要到而立之年了，从走出学校到现在一直从事着所谓的IT工作，工作和生活，都是平淡的。</p><h2 id="不堪回首"><a href="#不堪回首" class="headerlink" title="不堪回首"></a>不堪回首</h2><p>有时候蓦然回首，想看看这么些年自己都干了什么，发现自己似乎什么都没干。我这几年都学了什么东西掌握了什么技能？我都遇到了哪些困难？那些困难都解决了吗它们是如何被解决的？我开心是什么时候？我失落又是在何时，令我开心和失落的，它们到底又是什么…种种的种种，统统都无迹可寻了。</p><h2 id="众里寻他"><a href="#众里寻他" class="headerlink" title="众里寻他"></a>众里寻他</h2><p>所以我想，是时候该记录点什么了，岁月如梭，一梭而过，生活中那些零星的点点滴滴终究会被这岁月之梭带走一去不返，唯一的办法，就只有适时地把它们一一记下。</p><p>我大抵是从今年才开始才不时地写东西的，大多都是工作中涉及到的一些技术类的读书笔记。我在百度云应用引擎<code>BAE</code>上部署了一个<code>WordPress</code>折腾了一下，写了一些东西，<code>WordPress</code>个人感觉挺不错的，<code>BAE</code>收费也很公道每天4毛钱，不过最近发现有些图片总是莫名其妙地不见了，自己添加的js貌似也没效果了，好像是被还原到过去某个时间点似的，反复两次之后就没有兴趣再去折腾了，自己尝试了一下<code>hexo</code>之后决定采用，原因有下：</p><ol><li><code>hexo</code>的自身优势(搭建、部署很简单，插件和主题也很多，使用方便)</li><li>我喜欢用<code>markdown</code>写东西</li><li>方便用<code>github</code>管理我的笔记</li><li>不花钱(除非自己想买个域名并绑定自己的github地址)</li></ol><p>在此也附上筛选之后的<code>hexo</code>+<code>github</code>搭建博客的相关资料：</p><ul><li><a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">GitHub Pages + Hexo搭建博客</a></li><li><a href="https://hexo.io/zh-cn/docs/" title="hexo中文文档" target="_blank" rel="noopener">hexo中文文档</a></li></ul><h2 id="即日启程"><a href="#即日启程" class="headerlink" title="即日启程"></a>即日启程</h2><p>相信做IT的都会发现一个有趣的现象：碰到问题的时候我们一般都会去网上寻求解答，搜了一阵之后找到一个满意的，参照之后也解决问题了，但是细心的我们会发现一个可怕的事实，这些能解决我们问题的文章或者是博客，很多居然都是几年前写的，心中顿时生出一阵可怕，TMD几年前我都在干什么。我是不是早就应该像他们一样开始写写博客什么的了？现在写是不是晚了点？</p><p>但是问题来了：既然网上这么多现成的解决方案，我碰到的时候一搜就能解决，那我干嘛还要自己再做重复的劳动去记录一份呢？正因为我们会这么自问，所以我们才没有养成记录的习惯，没有记录的习惯，我们才会经常发现上述有趣的现象。</p><p>一句话，你所看到的，只是别人的成果，而不是别人的过程，就如同你能用各种定理解决数学问题但是不知道这些定理是怎么出来的一样。如果养成记录的习惯，那我们不仅自己经历了过程，也给别人分享了成果，记录让别人分享我们的生活，而我们自己，却是在活生生地生活。</p><p>所以，打今儿起，开始记录吧!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/9QAEkTc.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://balderdasher.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随记" scheme="https://balderdasher.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
      <category term="hexo" scheme="https://balderdasher.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://balderdasher.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Java中的引用Reference</title>
    <link href="https://balderdasher.github.io/2021/09/29/references-in-java/"/>
    <id>https://balderdasher.github.io/2021/09/29/references-in-java/</id>
    <published>2021-09-29T06:04:29.564Z</published>
    <updated>2021-09-29T06:04:29.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<code>jdk 1.2</code>之前的Java中，若一个对象不被任何变量所引用，那么程序就无法在使用这个对象。也就是说只有对象只有在<code>可触及状态（reachable）</code>下才能被程序所使用。从jdk 1.2开始增加了<code>java.lang.ref</code>包，此包提供了引用对象类，支持在某种程度上与垃圾回收器之间的交互。程序可以使用一个引用对象来维持对另外某一对象的引用，所采用的方式是使后者仍然可以被回收器回收。程序还可以安排在回收器确定某一给定对象的可到达性已经更改之后的某个时间得到通知。<br>在原来只有强引用的基础上新增了<code>软引用(SoftReference)</code>、<code>弱引用(WeakReference)</code>、<code>虚引用(PhantomReference)</code>3种对象引用类型。</p></blockquote><a id="more"></a><h2 id="引用包规范"><a href="#引用包规范" class="headerlink" title="引用包规范"></a>引用包规范</h2><p><em>引用对象</em><code>Reference</code>封装了对另一个对象<code>T</code>的引用，这样就可以像其他任何对象一样检查和操作引用自身。有三种类型的引用对象，按从弱到强依次为： <em>软</em> 引用、 <em>弱</em> 引用和 <em>虚</em> 引用。正如下面定义的那样，每种类型对应于一个不同的可到达性级别。软引用适用于实现内存敏感的缓存，弱引用适用于实现无法防止其键（或值）被回收的规范化映射，而虚引用则适用于以某种比 Java 终结机制更灵活的方式调度 <code>pre-mortem</code> 清除操作。</p><p>每种引用对象类型都是通过抽象的基本 <code>Reference</code> 类的一个子类实现的。其中一个子类的实例封装了对特定对象的引用，该对象名为指示对象。每个引用对象都提供了获取和清除该引用的方法。引用对象是不可变的，因此，除了清除操作之外，没有提供 set 操作。通过添加任何所需的字段和方法，程序可以为这些子类进一步创建子类，或者可以不加更改地使用这些子类。</p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>在创建引用对象时，通过向 <em>引用队列</em> 注册 一个适当的引用对象，程序可以请求在对象可到达性更改时获得通知。在垃圾回收器确定引用的可到达性已经更改为对应于引用类型的值之后的某一时间，它会将引用添加到相关的队列中。此时，该引用被认为是 <em>已加入队列的</em>（<code>Enqueued</code>）。通过轮询或阻塞，直到获得了引用，程序才可以从队列中移除引用。引用队列是通过 <code>ReferenceQueue</code> 类实现的。</p><p>已注册的引用对象及其队列之间的关系是单向的。也就是说，队列不会追踪那些向它注册的引用。如果一个已注册的引用本身变得不可到达，则永远不会将它加入到队列中。使用引用对象的程序的责任是，只要程序对其指示对象感兴趣，就要确保对象是可达到的。</p><p>虽然某些程序会选择专门使用一个线程从一个或多个队列中移除引用对象并处理它们，但这是绝对没有必要的。一种通常很有用的策略是：在执行另一个相当频繁的操作期间检查引用队列。例如，使用弱引用来实现弱键的哈希表能在每次访问表时轮询其引用队列。这就是 <code>WeakHashMap</code> 类的工作方式。因为 <code>ReferenceQueue.poll()</code> 方法仅仅检查内部数据结构，此检查只为哈希表访问方法增加了很小的系统开销。</p><h3 id="自动清除引用"><a href="#自动清除引用" class="headerlink" title="自动清除引用"></a>自动清除引用</h3><p>在将<em>软引用</em>和<em>弱引用</em>添加到向其注册的队列（如果有）之前，回收器将自动清除这些引用。所以，软引用和弱引用不需要向队列注册即可使用，而虚引用则需要这样做。通过虚引用可到达的对象将仍然保持原状，直到清除所有这类引用或者它们本身变得不可到达。</p><h3 id="可到达性"><a href="#可到达性" class="headerlink" title="可到达性"></a>可到达性</h3><p>从最强到最弱，不同的可到达性级别反映了对象的生命周期。在操作上，可将它们定义如下：</p><ul><li>如果某一线程可以不必遍历所有引用对象而直接到达一个对象，则该对象是<em>强可到达</em> 对象。新创建的对象对于创建它的线程而言是强可到达对象。</li><li>如果一个对象不是强可到达对象，但通过遍历某一软引用可以到达它，则该对象是<em>软可到达</em> 对象。</li><li>如果一个对象既不是强可到达对象，也不是软可到达对象，但通过遍历弱引用可以到达它，则该对象是弱可到达 对象。当清除对某一弱可到达对象的弱引用时，便可以终止此对象了。</li><li>如果一个对象既不是强可到达对象，也不是软可到达对象或弱可到达对象，它已经终止，并且某个虚引用在引用它，则该对象是<em>虚可到达</em> 对象。</li><li>最后，当不能以上述任何方法到达某一对象时，该对象是<em>不可到达</em> 对象，因此可以回收此对象。</li></ul><h2 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><blockquote><p>泛型类<code>Reference</code>是几种新增引用类型的抽象基类，因为引用对象是通过与垃圾回收器的密切合作来实现的，所以不能直接为此类创建子类。</p></blockquote><p>以上是此类的API文档上说的，乍一看很是费解，怎么就不能直接为此类创建子类了，上面提到的几种引用不都是直接继承的它吗，这话到底是什么意思呢？</p><p>其实<code>Reference</code>类不能直接创建子类的意思可以理解为我们在写代码的时候不能直接继承它，因为<code>Reference</code>的直接子类(软、弱、虚、final)都是由jvm定制化处理的，在代码中直接继承于它没有任何作用，只能继承或使用它的子类。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reference(T referent) &#123;</span><br><span class="line">    <span class="keyword">this</span>(referent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = referent;</span><br><span class="line">    <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reference类共有两个构造函数，都表示构造一个指向<code>T</code>类型对象的引用。其区别在于带不带<code>ReferenceQueue</code>类型的<code>queue</code>参数，带queue的意义在于我们可以在外部对这个queue进行监控，如果有对象即将被回收，那么相应的<code>Reference</code>对象就会被放入这个queue中，然后我们可以拿到引用对象做进一步的处理。</p><p>构造函数中<code>T</code>类型的参数<code>referent</code>表示这个引用所指向的对象，这个对象即将被回收意味着此对象除了被指向它的<code>reference</code>引用之外没有其它引用了（并非真没有，而是gcRoot可达性分析之后确定为不可达，以避免循环引用问题）。</p><p>构造函数中<code>ReferenceQueue</code>类型的<code>queue</code>参数即是<code>T</code>对象即被回收时所要通知的队列,当对象即被回收时,整个reference对象(而不是被回收的对象)会被放到queue里面,然后外部程序即可通过监控这个queue拿到相应的数据了。</p><p>如果没有queue参数，就只有不断轮询Reference对象，通过判断里面的<code>get()</code>是否返回<code>null</code>（虚引用不能这么做，因为它的get始终返回null，因此它只有带queue的构造函数）来判断它所指向的对象是否被回收。这两种方法都有相应的使用场景，如<code>WeakHashMap</code>选择去查询queue来判断是否有对象将被回收，而<code>ThreadLocalMap</code>则采用判断<code>get()</code>是否为null来做处理。</p><h3 id="辅助类ReferenceQueue"><a href="#辅助类ReferenceQueue" class="headerlink" title="辅助类ReferenceQueue"></a>辅助类ReferenceQueue</h3><p>引用队列<code>ReferenceQueue</code>类是使用几种引用时的辅助类，它的作用是在使用几种引用时方便监控我们所创建的引用的状态变化，如果构造一个指向<code>T</code>对象的引用时指定了一个引用队列，那么此队列将监控所有<code>T</code>类型对象的可达性状态变化，当gc决定此对象可达性改变时，相应的引用将会进入队列，我们可以从队列中取出此引用以便在对象回收之前做出处理。</p><p>从名字上来看，<code>ReferenceQueue</code>似乎是一个队列，但其内部并没有实际的存储结构，它的存储是依赖<code>Reference</code>节点之间关系，因为Reference中的<code>next</code>字段存储了它的下一个节点，所以多个Reference形成了一个链表，ReferenceQueue可以看做是这个链表的容器，不过它只存储链表的头结点(<code>head</code>)。</p><h3 id="Reference的状态"><a href="#Reference的状态" class="headerlink" title="Reference的状态"></a>Reference的状态</h3><p>每个引用对象都有自己相应的状态值，即描述自身及引用所指示对象<code>T</code>当前处于什么样的状态，方便进行查询、定位或处理。</p><ul><li><code>Active</code>：活动状态，即引用所指示的对象处于强引用状态，还没有被回收，此状态下引用对象不会被放入引用队列中（如果定义时注册了引用队列）,新创建的引用对象处于活动状态</li><li><code>Pending</code>：等待状态，准备放入引用队列中，在此状态下要处理的引用对象将排队等到放入引用队列中，在这个时间窗口，相应的引用对象为pending状态，进入到此状态的任何reference可认为<code>next</code>为自身（jvm设置），创建时未注册引用队列的引用对象将永远不会是等待状态</li><li><code>Enqueued</code>：进入状态，引用对象所指向的对象已经为等待回收，并且相应的引用对象已经放到引用队列中了，准备由外部线程来从queue中获取相应数据，此状态下，next为下一个要处理的对象，queue为特殊标识对象<code>ENQUEUED</code>，创建时未注册引用队列的引用对象将永远不可能是进入状态</li><li><code>Inactive</code>：不活动状态，即此引用对象已经由外部从引用队列中获取到并且已经处理掉了，意味着此引用对象指向的对象T可以被回收，并且引用对象本身reference也可以被回收了，所以进入此状态的引用对象肯定是应该被回收掉的。一旦一个引用对象进入此状态，那么它的状态将不会再改变了。</li></ul><p>jvm不需要定义相应的状态值来判断引用处于哪个状态，而是通过计算<code>next</code>和<code>queue</code>进行判断。</p><h2 id="Reference实现原理"><a href="#Reference实现原理" class="headerlink" title="Reference实现原理"></a>Reference实现原理</h2><p>当使用几种类型的Reference时，只要初始化了一个<code>Reference</code>对象<code>ref</code>，Reference内部的静态块代码就会创建并启动处理引用的线程<code>ReferenceHandler</code>就会自动运行，这是一个最高优先级的守护线程，此线程做的事就是一直运行处理<code>Pending</code>状态的引用，如果发现合适的引用则将其放入注册的引用队列。其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryHandlePending</span><span class="params">(<span class="keyword">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class="line">    Reference&lt;Object&gt; r;</span><br><span class="line">    Cleaner c;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;<span class="comment">// 如果有pending状态的引用</span></span><br><span class="line">                r = pending;<span class="comment">// 拿到pending状态的引用</span></span><br><span class="line">                <span class="comment">// 'instanceof' might throw OutOfMemoryError sometimes</span></span><br><span class="line">                <span class="comment">// so do this before un-linking 'r' from the 'pending' chain...</span></span><br><span class="line">                c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 将此引用从pending链断开</span></span><br><span class="line">                pending = r.discovered;</span><br><span class="line">                r.discovered = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// The waiting on the lock may cause an OutOfMemoryError</span></span><br><span class="line">                <span class="comment">// because it may try to allocate exception objects.</span></span><br><span class="line">                <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// retry if waited</span></span><br><span class="line">                <span class="keyword">return</span> waitForNotify;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        <span class="comment">// Give other threads CPU time so they hopefully drop some live references</span></span><br><span class="line">        <span class="comment">// and GC reclaims some space.</span></span><br><span class="line">        <span class="comment">// Also prevent CPU intensive spinning in case 'r instanceof Cleaner' above</span></span><br><span class="line">        <span class="comment">// persistently throws OOME for some time...</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">        <span class="comment">// retry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">        <span class="comment">// retry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path for cleaners</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">        c.clean();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 若注册了引用队列则放入其中，进入enqueued状态</span></span><br><span class="line">    ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span><br><span class="line">    <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>discovered</code>,表示要处理的对象的下一个对象.即可以理解要处理的对象也是一个链表,通过discovered进行排队,这边只需要不停地拿到pending,然后再通过discovered不断地拿到下一个对象即可.因为这个pending对象,两个线程都可能访问,因此需要加锁处理.</p><p>引用从pending状态到enqueued是通过<code>queue.enqueue(r)</code>操作，这是引用队列中的一个方法，只由Reference类调用，来看看里面都做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;? extends T&gt; r)</span> </span>&#123; <span class="comment">/* Called only by Reference class */</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 获得锁之后检查引用是否已经被加入过或者已经被移除</span></span><br><span class="line">        ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">        <span class="keyword">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> queue == <span class="keyword">this</span>;</span><br><span class="line">        r.queue = ENQUEUED;<span class="comment">// 设置已入队状态</span></span><br><span class="line">        r.next = (head == <span class="keyword">null</span>) ? r : head;<span class="comment">//后进先出的队列，后进来的引用先被取出处理</span></span><br><span class="line">        head = r;</span><br><span class="line">        queueLength++;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.notifyAll();<span class="comment">//发布通知可以从中取出引用处理了如remove方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个引用进入队列之后，说明这个引用所指向的对象将要被回收了，这时候我们可以从队列中取出引用以便进行回收前的一些处理，从队列中取出引用的操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Reference&lt;? extends T&gt; poll() &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有将被回收的对象，返回null</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">return</span> reallyPoll();<span class="comment">//否则链表操作加锁并从中取出引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Reference&lt;? extends T&gt; reallyPoll() &#123;       <span class="comment">/* Must hold lock */</span></span><br><span class="line">    Reference&lt;? extends T&gt; r = head;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;<span class="comment">// 和放入队列的逻辑相同：取出头引用处理并重新设置头</span></span><br><span class="line">        head = (r.next == r) ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            r.next; <span class="comment">// Unchecked due to the next field having a raw type in Reference</span></span><br><span class="line">        r.queue = NULL;<span class="comment">//确保取出的引用不会再被放入队列</span></span><br><span class="line">        r.next = r;</span><br><span class="line">        queueLength--;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>poll()</code>方法可以从引用队列中取出将要被回收的对象引用外，还有<code>remove()</code>、<code>remove(long timeout)</code>方法具有相同的功能，它们相当于轮询版的<code>poll()</code>，这个两个方法会一直阻塞直到有引用被放入队列中或者超时时间已过。</p><p>remove方法在<code>Finalizer</code>中有相应的应用场景，此类是jvm专用用来处理对象在被回收时执行对象中<code>finalize()</code>方法的，自动启动一个线程不断从注册的队列中取出引用并在回收指向对象时执行其<code>finalize()</code>方法。</p><h2 id="几种引用"><a href="#几种引用" class="headerlink" title="几种引用"></a>几种引用</h2><ol><li><code>SoftReference</code>：软引用，这种引用会根据内存需求任凭被垃圾回收器清除，即内存充足时不会被回收，反之被回收，因此软引用常被用来实现内存敏感的缓存。jvm会保证所有指向软可达对象的软引用在抛出<code>OOM</code>之前被清除。</li><li><code>WeakReference</code>：弱引用，它们并不禁止其指示对象变得可终结，并被终结，然后被回收。弱引用最常用于实现规范化的映射。假定垃圾回收器确定在某一时间点上某个对象是弱可到达对象。这时，它将自动清除针对此对象的所有弱引用，以及通过强引用链和软引用，可以从其到达该对象的针对任何其他弱可到达对象的所有弱引用。同时它将声明所有以前的弱可到达对象为可终结的。在同一时间或晚些时候，它将那些已经向引用队列注册的新清除的弱引用加入队列。</li><li><code>PhantomReference</code>：虚引用，在回收器确定其指示对象可另外回收之后，被加入队列。虚引用最常见的用法是以某种可能比使用 Java 终结机制更灵活的方式来指派 pre-mortem 清除动作。<ul><li>如果垃圾回收器确定在某一特定时间点上虚引用的指示对象是虚可到达对象，那么在那时或者在以后的某一时间，它会将该引用加入队列。</li><li>为了确保可回收的对象仍然保持原状，虚引用的指示对象不能被获取：虚引用的 get 方法总是返回 null。</li><li>与软引用和弱引用不同，虚引用在加入队列时并没有通过垃圾回收器自动清除。通过虚引用可到达的对象将仍然保持原状，直到所有这类引用都被清除，或者它们都变得不可到达。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在&lt;code&gt;jdk 1.2&lt;/code&gt;之前的Java中，若一个对象不被任何变量所引用，那么程序就无法在使用这个对象。也就是说只有对象只有在&lt;code&gt;可触及状态（reachable）&lt;/code&gt;下才能被程序所使用。从jdk 1.2开始增加了&lt;code&gt;java.lang.ref&lt;/code&gt;包，此包提供了引用对象类，支持在某种程度上与垃圾回收器之间的交互。程序可以使用一个引用对象来维持对另外某一对象的引用，所采用的方式是使后者仍然可以被回收器回收。程序还可以安排在回收器确定某一给定对象的可到达性已经更改之后的某个时间得到通知。&lt;br&gt;在原来只有强引用的基础上新增了&lt;code&gt;软引用(SoftReference)&lt;/code&gt;、&lt;code&gt;弱引用(WeakReference)&lt;/code&gt;、&lt;code&gt;虚引用(PhantomReference)&lt;/code&gt;3种对象引用类型。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="https://balderdasher.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://balderdasher.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper知识点</title>
    <link href="https://balderdasher.github.io/2020/07/18/zookeeper%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://balderdasher.github.io/2020/07/18/zookeeper知识点/</id>
    <published>2020-07-18T15:13:06.000Z</published>
    <updated>2021-09-29T06:04:29.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zookeeper的leader选举机制"><a href="#zookeeper的leader选举机制" class="headerlink" title="zookeeper的leader选举机制"></a>zookeeper的leader选举机制</h2><ol><li>集群中每台机器启动时都会先投给自己一票</li><li>然后与其它已经启动的机器交流选票决定自己的票投给哪台机器</li><li>决定投给哪台机器的规则为先比较zxid，如果zxid一致的话比较myid，投给当前myid最大者</li><li>如果有机器的选票数量超过半数机器，则当选为<code>leader</code>，其余机器为<code>flower</code></li></ol><h2 id="zookeeper服务器的三种角色"><a href="#zookeeper服务器的三种角色" class="headerlink" title="zookeeper服务器的三种角色"></a>zookeeper服务器的三种角色</h2><ul><li><p>Leader角色：Leader服务器是zk集群工作的核心，其主要工作有两个：</p><ol><li>事务请求的唯一调度者和处理者，保证集群事务处理的顺序性。</li><li>集群内部各个服务器的调度者</li></ol></li><li><p>Follower角色：Follower是zk集群的跟随者，其主要工作有三个：</p><ol><li>处理客户端非事务性请求，转发事务请求给Leader服务器（事务请求都由Leader处理）</li><li>参与事务请求Proposal的投票</li><li>参与Leader选举投票 </li></ol></li><li><p>Observer角色：Observer充当观察者角色，观察zk集群的最新状态变化并将这些状态同步过来，对于非事务请求可以进行独立的处理，对于事务请求，则会转发给Leader服务器进行处理，Observer不会参与任何形式的投票，包括事务请求Proposal的投票和Leader选举的投票。场景：集群机器非常多，所以把大部分机器当做观察者（人民群众），一小部分机器参与投票（人大代表），leader只收集小部分机器的投票结果即可，提高了写数据的性能（减少参与投票的机器数）</p></li></ul><h2 id="zookeeper服务器四种状态"><a href="#zookeeper服务器四种状态" class="headerlink" title="zookeeper服务器四种状态"></a>zookeeper服务器四种状态</h2><ul><li>looking：寻找leader状态，当前服务器处于该状态时，它会认为当前集群中没有leader，因此需要进入leader选举状态</li><li>flowing：跟随者状态，表示当前服务器的角色是Follower角色</li><li>leading：领导者状态，表示当前服务器是Leader</li><li>observing：观察者状态，表示当前服务器角色是Observer</li></ul><h2 id="zookeeper如何保证数据一致性"><a href="#zookeeper如何保证数据一致性" class="headerlink" title="zookeeper如何保证数据一致性"></a>zookeeper如何保证数据一致性</h2><p>通过zab协议保持数据一致性,zab协议参照paxos协议实现,主要有以下两点</p><ul><li>崩溃恢复：没有leader状态时先选leader，崩溃不一定恢复，必须投票数超过半数机器才会选出leader，集群对外正常提供服务</li><li>正常读写：有leader时正常按照leader广播进行读写，如果发现自己的投票与大部分机器不一致时，崩溃重启（自杀），同步leader的数据，每台机器会有一个待写队列，leader广播可写时写入，不同意写入时回滚（从待写队列移除）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;zookeeper的leader选举机制&quot;&gt;&lt;a href=&quot;#zookeeper的leader选举机制&quot; class=&quot;headerlink&quot; title=&quot;zookeeper的leader选举机制&quot;&gt;&lt;/a&gt;zookeeper的leader选举机制&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="zookeeper" scheme="https://balderdasher.github.io/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="https://balderdasher.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>算法第三章-搜索之二叉查找树</title>
    <link href="https://balderdasher.github.io/2018/03/09/algorithm-searching-bst/"/>
    <id>https://balderdasher.github.io/2018/03/09/algorithm-searching-bst/</id>
    <published>2018-03-09T08:17:38.000Z</published>
    <updated>2021-09-29T06:04:29.572Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>定义</strong>：一棵二叉查找树（<code>BST</code>）是一个二叉树，其中每个结点都含有一个<code>Comparable</code>的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。</p></blockquote><p><img src="/uploads/algorithm/searching/binary-tree-anatomy.png" alt="binary-tree-anatomy"></p><h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2><p>和链表一样，需要定义一个私有类来表示二叉查找树上的一个结点。每个结点都含有一个键、一个值、一条左链接、一条右链接和一个结点计数器。左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找树，变量N给出了以该结点为根的子树的结点总数，空链接的值会被当做0，这样就能保证以下公式对于二叉树中的任意结点<code>x</code>总是成立：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size(x) = size(x.left) + size(x.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p><img src="/uploads/algorithm/searching/bst-subtree-count.png" alt="bst-subtree-count"></p><p>程序表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;          <span class="comment">// 二叉查找树的根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Key key;        <span class="comment">// 键</span></span><br><span class="line">        <span class="keyword">private</span> Value val;      <span class="comment">// 值</span></span><br><span class="line">        <span class="keyword">private</span> Node left;      <span class="comment">// 左链接</span></span><br><span class="line">        <span class="keyword">private</span> Node right;     <span class="comment">// 右链接</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n;          <span class="comment">// 以该结点为根的子树中的结点总数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.n = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value val)</span></span>&#123;&#125;<span class="comment">//TODO</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;&#125;<span class="comment">//TODO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...other API methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>在二叉查找树中查找一个键的递归算法：如果树是空的，则未命中；如果被查找的键和根结点的键相等，查找命中，否则就递归地在适当的子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。</p><p><img src="/uploads/algorithm/searching/bst-search.png" alt="bst-search"></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>二叉查找树的插入操作和查找操作差不多。如果树是空的，就返回一个含有该键值对的新结点；如果被查找的键小于根结点的键，那就继续在左子树中插入该键，否则在右子树中插入该键。<br><img src="/uploads/algorithm/searching/bst-insert.png" alt="bst-insert"></p><p>二叉查找树中查找和插入方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取键值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 搜索键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 键对应的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在以x为根结点的子树中查找并返回key对应的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x   子树的根结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 查找键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 命中返回key对应的value，否则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="comment">// 比较key与当前子树根结点的key的大小决定在左还是右子树中搜索</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> get(x.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> get(x.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入键值对</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">    root = put(root, key, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果key存在于以x为根结点的子树中则更新它的值</span></span><br><span class="line">    <span class="comment">// 否则将以key和val为键值对的新结点插入到该子树中</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x.left = put(x.left, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        x.right = put(x.right, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    x.n = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>使用二叉查找树的算法的运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。在最好的情况下，一棵含有<code>N</code>个结点的树是完全平衡的，每条空链接和根结点的距离都为<code>~lgN</code>。在最坏的情况下，搜索路径上可能有<code>N</code>个结点，如下图所示，但是一般情况下树的形状和最好情况更接近。</p><p><img src="/uploads/algorithm/searching/bst-analyze.png" alt="bst-analyze"></p><h2 id="有序性相关的方法与删除操作"><a href="#有序性相关的方法与删除操作" class="headerlink" title="有序性相关的方法与删除操作"></a>有序性相关的方法与删除操作</h2><blockquote><p>二叉查找树广泛使用的原因就是它能够<code>保持键的有序性</code>，因此它可以作为实现有序符号表API中众多方法的基础，以下就是对API中各个方法实现的研究</p></blockquote><ul><li><p><strong>最大键和最小键</strong>：如果根结点为空，则一棵二叉查找树中最小的键就是根结点；如果左链接非空，那么树中最小键就是左子树中的最小键，同理，找出最大键的方法也是类似的，只是变为查找右子树而已。</p></li><li><p><strong>向上取整和向下取整</strong>：如果给定的键<code>key小于</code>二叉查找树的根结点的键，那么小于等于<code>key</code>的最大键（<code>floor</code>）一定在根结点的左子树中；如果给定的键<code>key</code>大于二叉查找树的根结点，那么只有当根结点右子树中存在小于等于<code>key</code>的结点时，小于等于<code>key</code>的最大键才会出现在右子树中，否则根结点就是小于等于<code>key</code>的最大键。这就是<code>floor()</code>方法的递归实现，将左变为右（同时将<code>小于</code>变为<code>大于</code>）就能够得到<code>ceiling()</code>的算法。向上取整函数的计算如图所示：<br><img src="/uploads/algorithm/searching/bst-floor.png" alt="bst-floor"></p></li></ul><p>二叉查找树中<code>max()</code>、<code>min()</code>、<code>floor()</code>、<code>ceiling()</code>方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最小键</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 树中最小的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min(root).key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果根结点的左链接为空，最小键就是根结点</span></span><br><span class="line">    <span class="comment">// 否则为左子树中的最小键</span></span><br><span class="line">    <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min(x.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大键</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 树中最大的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(root).key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">max</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果根结点的右链接为空，最大键就是根结点</span></span><br><span class="line">    <span class="comment">// 否则为右子树中的最大键</span></span><br><span class="line">    <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max(x.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向下取整：找出小于等于给定key的最大键</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    Node x = floor(root, key);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key小于根结点的key时在左子树</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> floor(x.left, key);</span><br><span class="line">        <span class="comment">// key大于根结点的key并且当根结点右子树中存在小于等于key的结点时会在右子树中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span> &amp;&amp; x.right.key.compareTo(key) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> floor(x.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则即为根结点的key</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向上取整：找出大于等于给定key的最小键</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">ceiling</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    Node x = ceiling(root, key);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">ceiling</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="comment">// key大于根结点的key时在右子树</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ceiling(x.right, key);</span><br><span class="line">        <span class="comment">// key小于根结点的key并且当根结点左子树中存在大于等于key的结点时会在左子树中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span> &amp;&amp; x.left.key.compareTo(key) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ceiling(x.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则即为根结点的key</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>选择操作</strong>：假设想找到排名为<code>k</code>的键（即树中正好有<code>k</code>个小于它的键）。如果左子树中的结点数<code>t</code>大于<code>k</code>，那么久继续（递归地）在左子树中查找排名为<code>k</code>的键；如果<code>t</code>等于<code>k</code>，就返回根结点中的键；如果<code>t</code>小于<code>k</code>，就递归地在右子树中查找排名为（<code>k-t-1</code>）的键。</li><li><strong>排名</strong>：<code>rank()</code>是<code>select()</code>的逆方法，它会返回给定键的排名。它的实现和<code>select()</code>类似：如果给定的键和根结点的键相等，返回左子树中的结点数<code>t</code>；如果给定的键小于根结点，返回该键在左子树中的排名（递归）；如果给定的键大于根结点，返回<code>t+1</code>（根结点）加上它在右子树中的排名（递归计算）。</li></ul><p>二叉查找树中的选择和排名操作的实现算法如下所示：<br><img src="/uploads/algorithm/searching/bst-select.png" alt="bst-select"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回符号表中第k小的键</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 排名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 符号表中第k小的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt;= size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called select() with invalid argument: "</span> + k);</span><br><span class="line">    &#125;</span><br><span class="line">    Node x = select(root, k);</span><br><span class="line">    <span class="keyword">return</span> x.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回排名为k的结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">select</span><span class="params">(Node x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = size(x.left);</span><br><span class="line">    <span class="keyword">if</span> (t &gt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> select(x.left, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> select(x.right, k - t - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排名：返回符号表中小于给定键的键总数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 给定key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 符号表中小于给定键的键总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to rank() is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rank(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以x为根结点的子树中小于x.key的键的数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rank(x.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + size(x.left) + rank(x.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size(x.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>删除最大和最小键</strong>：对于删除最小值<code>deleteMin()</code>，不断深入根结点的左子树直到遇见一个空链接，然后将指向该结点的链接指向该结点的右子树（只需在递归调用中返回它的右链接即可），此时已经没有任何链接指向要删除的结点，因此它会被垃圾收集器清理掉，删除最大值的方法<code>deleteMax()</code>和<code>deleteMin()</code>类似。</li></ul><ul><li><strong>删除操作</strong>：我们可以用类似删除最大键或删除最小键的方法删除一个只有一个子结点或没有子结点的结点，但是删除一个拥有两个子结点却不是一件容易的事，因为删除之后我们要处理两棵子树，但被删除结点的父结点只有一条空出来的链接。<code>T.Hibbard</code>在1962年提出了解决这个难题的第一个方法：在删除结点<code>x</code>后用它的<code>后继结点</code>填补它的位置。因为<code>x</code>有一个右子结点，因此它的后继结点就是其右子树中的最小结点。这样的替换仍然能够保证树的有序性，因为<code>x.key</code>和它的后继结点的键之间不存在其他的键。我们能够用4个步骤完成将<code>x</code>替换为它的后继结点的任务：</li></ul><ol><li>将指向即将被删除的结点的链接保存为<code>t</code>；</li><li>将<code>x</code>指向它的后继结点<code>min(t.right)</code>;</li><li>将<code>x</code>的右链接（原本指向一棵所有结点都大于<code>x.key</code>的二叉查找树）指向<code>deleteMin(t.right)</code>,也就是在删除后所有结点仍然都大于<code>x.key</code>的子二叉查找树；</li><li>将<code>x</code>的左链接（本为空）设为<code>t.left</code>（其下所有的键都小于被删除的结点和它的后继结点）。<br><img src="/uploads/algorithm/searching/bst-deletemin.png" alt="bst-deletemin">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/uploads/algorithm/searching/bst-delete.png" alt="bst-delete"></li></ol><p>以上方法尽管能正确地删除一个结点，但它的一个缺陷是可能会再某些实际应用中产生性能问题，这个问题在于选用后继结点是一个随意的决定，且没有考虑树的对称性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被删除结点的value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"called delete() with a null key"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    root = delete(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x.left = delete(x.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        x.right = delete(x.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x.right;</span><br><span class="line">        &#125;</span><br><span class="line">        Node t = x;</span><br><span class="line">        x = min(t.right);   <span class="comment">// 后继结点为min(t.right)</span></span><br><span class="line">        x.right = deleteMin(t.right);</span><br><span class="line">        x.left = t.left;</span><br><span class="line">    &#125;</span><br><span class="line">    x.n = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除最小的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"symbol table underflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    root = deleteMin(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.right;</span><br><span class="line">    &#125;</span><br><span class="line">    x.left = deleteMin(x.left);</span><br><span class="line">    x.n = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除最大键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Symbol table underflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    root = deleteMax(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.left;</span><br><span class="line">    &#125;</span><br><span class="line">    x.right = deleteMax(x.right);</span><br><span class="line">    x.n = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：一棵二叉查找树（&lt;code&gt;BST&lt;/code&gt;）是一个二叉树，其中每个结点都含有一个&lt;code&gt;Comparable&lt;/code&gt;的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/algorithm/searching/binary-tree-anatomy.png&quot; alt=&quot;binary-tree-anatomy&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据表示&quot;&gt;&lt;a href=&quot;#数据表示&quot; class=&quot;headerlink&quot; title=&quot;数据表示&quot;&gt;&lt;/a&gt;数据表示&lt;/h2&gt;&lt;p&gt;和链表一样，需要定义一个私有类来表示二叉查找树上的一个结点。每个结点都含有一个键、一个值、一条左链接、一条右链接和一个结点计数器。左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找树，变量N给出了以该结点为根的子树的结点总数，空链接的值会被当做0，这样就能保证以下公式对于二叉树中的任意结点&lt;code&gt;x&lt;/code&gt;总是成立：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;size(x) = size(x.left) + size(x.right) + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/algorithm/searching/bst-subtree-count.png&quot; alt=&quot;bst-subtree-count&quot;&gt;&lt;/p&gt;
&lt;p&gt;程序表示：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BST&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Key&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;Value&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Node root;          &lt;span class=&quot;comment&quot;&gt;// 二叉查找树的根结点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Key key;        &lt;span class=&quot;comment&quot;&gt;// 键&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Value val;      &lt;span class=&quot;comment&quot;&gt;// 值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Node left;      &lt;span class=&quot;comment&quot;&gt;// 左链接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Node right;     &lt;span class=&quot;comment&quot;&gt;// 右链接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n;          &lt;span class=&quot;comment&quot;&gt;// 以该结点为根的子树中的结点总数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Key key, Value val, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.key = key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.val = val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.n = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Key key,Value val)&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;span class=&quot;comment&quot;&gt;//TODO&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Value &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Key key)&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;span class=&quot;comment&quot;&gt;//TODO&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//...other API methods&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="https://balderdasher.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://balderdasher.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="搜索" scheme="https://balderdasher.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>算法第三章-搜索之散列表</title>
    <link href="https://balderdasher.github.io/2018/03/08/algorithm-searching-hashtable/"/>
    <id>https://balderdasher.github.io/2018/03/08/algorithm-searching-hashtable/</id>
    <published>2018-03-08T06:09:16.000Z</published>
    <updated>2021-09-29T06:04:29.573Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果所有的键都是小整数，可以用一个数组来实现无序的符号表，将键作为数组的索引而数组中键<code>i</code>处存储的就是它对应的值，这样就可以快速访问任意键的值，<code>散列表</code>是这种简易方法的扩展并能处理更加复杂的类型的键，只需要用算术操作将键转化为数组的索引来访问数组中的键值对<br><img src="/uploads/algorithm/searching/hashing-crux.png" alt="hashing-crux"><br>使用散列的查找算法分为两步：第一步是用<code>散列函数</code>将被查找的键转化为数组的一个索引。理想情况下不同的键都能转化为不同的索引值。但是这只是理想情况下，所以我们需要面对两个或者多个键都会散列到相同的索引值的情况，因此，散列查找的第二步就是一个<code>处理碰撞冲突</code>的过程，后面会学到两种方法：<code>拉链法和线性探测法</code>。</p></blockquote><a id="more"></a><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><blockquote><p>如果有一个能够保存<code>M</code>个键值对的数组，那么就需要一个能够将任意键转化为该数组范围内的索引<code>([0,M-1]范围内的整数)</code>的<code>散列函数</code>。<br>散列函数和键的类型有关，严格地说，<code>对于每种类型的键都需要一个与之对应的散列函数</code>。</p></blockquote><ul><li><strong>正整数</strong> 将整数散列最常用方法是<code>除留余数法</code>。选择大小为素数<code>M</code>的数组，对于任意正整数<code>k</code>，计算<code>k</code>除以<code>M</code>的余数。此计算很容易并能够有效地将键散布在<code>0</code>到<code>M-1</code>的范围内。</li><li><strong>浮点数</strong> 如果键是0到1之间的实数，可以将它乘以<code>M</code>并四舍五入得到一个<code>0</code>到<code>M-1</code>之间的索引值。此方法容易理解但是有缺陷，因为这种情况下键的高位起的作用更大，最低位对散列的结果没有影响，修正这个问题的办法是将键表示为二进制数然后再使用除留余数法(java就是这么做的)。</li><li><p><strong>字符串</strong> 除留余数法也可以处理较长的键，例如字符串，只需将它们当做大整数即可，如以下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">    hash = (R * hash + s.charAt(i)) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>组合键</strong> 如果键的类型含有多个整型变量，可以和<code>String</code>类型一样将它们混合起来。</p></li><li><strong>软缓存</strong> 如果散列值的计算很耗时，可以将<code>每个键的散列值缓存起来</code>，即在每个键中使用一个hash变量来保存它的<code>hashCode()</code>的返回值，第一次调用<code>hashCode()</code>时计算对象的散列值，之后对<code>hashCode()</code>方法的调用会直接返回hash变量的值，java的<code>String</code>对象的<code>hashCode()</code>就是采用这种方法来减少计算量。</li></ul><p>总的来说，要为一个数据类型实现一个优秀的散列方法需要满足以下三个条件：</p><ol><li>一致性——等价的键必然产生相等的散列值</li><li>高效性——计算简便</li><li>均匀性——均匀地散列所有的键</li></ol><h2 id="基于拉链法的散列表"><a href="#基于拉链法的散列表" class="headerlink" title="基于拉链法的散列表"></a>基于拉链法的散列表</h2><blockquote><p>一个散列函数能够将键转化为数组索引。散列算法的第二步是<code>碰撞处理</code>，也就是处理两个或多个键的散列值相同的情况。一种直接的办法是将大小为<code>M</code>的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。这种方法被称为<code>拉链法</code>，因为发生冲突的元素都被存储在链表中。这个方法的基本思想就是选择足够大的<code>M</code>，使得所有链表都尽可能端以保证高效的查找。查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。<br><img src="/uploads/algorithm/searching/separate-chaining.png" alt="separate-chaining"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrdios.competencymatrix.algorithm.searching.HashTables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mrdios.competencymatrix.algorithm.fundamentals.StacksAndQueues.queue.Queue;</span><br><span class="line"><span class="keyword">import</span> com.mrdios.competencymatrix.algorithm.searching.SymbolTables.SequentialSearchST;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于拉链法的散列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> huxiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017-04-25 15:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;                               <span class="comment">// 键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;                               <span class="comment">// 散列表的大小</span></span><br><span class="line">    <span class="keyword">private</span> SequentialSearchST&lt;Key, Value&gt;[] st; <span class="comment">// 存放链表对象的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">997</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建m条链表</span></span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        st = (SequentialSearchST&lt;Key, Value&gt;[]) <span class="keyword">new</span> SequentialSearchST[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            st[i] = <span class="keyword">new</span> SequentialSearchST();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            size += st[i].size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to contains() is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st[hash(key)].contanis(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to get() is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to put() is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        st[hash(key)].put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Key&gt; keys = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Key key : st[i].keys()) &#123;</span><br><span class="line">                keys.enqueue(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于线性探测法的散列表"><a href="#基于线性探测法的散列表" class="headerlink" title="基于线性探测法的散列表"></a>基于线性探测法的散列表</h3><blockquote><p>实现散列表的另一种方式就是用大小为<code>M</code>的数组保存<code>N</code>个键值对，其中<code>M&gt;N</code>。我们需要依靠数组中的<code>空位</code>解决碰撞冲突。基于这种策略的所有方法被称为<code>开放地址</code>散列表。</p><p>开放地址散列表中最简单的方法叫做<code>线性探测法</code>：当碰撞发生时，我们直接检查散列表中的下一个位置（将索引值加1）。这样的线性探测可能会产生三种结果：</p><ul><li>命中，该位置的键和被查找的键相同</li><li>未命中，键为空（该位置没有键）</li><li>继续查找，该位置的键和被查找的键不同<br><img src="/uploads/algorithm/searching/linear-probing.png" alt="linear-probing"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如果所有的键都是小整数，可以用一个数组来实现无序的符号表，将键作为数组的索引而数组中键&lt;code&gt;i&lt;/code&gt;处存储的就是它对应的值，这样就可以快速访问任意键的值，&lt;code&gt;散列表&lt;/code&gt;是这种简易方法的扩展并能处理更加复杂的类型的键，只需要用算术操作将键转化为数组的索引来访问数组中的键值对&lt;br&gt;&lt;img src=&quot;/uploads/algorithm/searching/hashing-crux.png&quot; alt=&quot;hashing-crux&quot;&gt;&lt;br&gt;使用散列的查找算法分为两步：第一步是用&lt;code&gt;散列函数&lt;/code&gt;将被查找的键转化为数组的一个索引。理想情况下不同的键都能转化为不同的索引值。但是这只是理想情况下，所以我们需要面对两个或者多个键都会散列到相同的索引值的情况，因此，散列查找的第二步就是一个&lt;code&gt;处理碰撞冲突&lt;/code&gt;的过程，后面会学到两种方法：&lt;code&gt;拉链法和线性探测法&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://balderdasher.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://balderdasher.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="搜索" scheme="https://balderdasher.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>算法第三章-搜索之符号表</title>
    <link href="https://balderdasher.github.io/2018/03/08/algorithm-searching-SymbolTables/"/>
    <id>https://balderdasher.github.io/2018/03/08/algorithm-searching-SymbolTables/</id>
    <published>2018-03-08T02:08:09.000Z</published>
    <updated>2021-09-29T06:04:29.573Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义：符号表是一种存储键值对的数据结构，支持两种操作：插入（<code>put</code>），即将一组新的键值对存入表中；查找（<code>get</code>），即根据给定的键得到相应的值。</p></blockquote><p>简单的泛型符号表的API如下图所示：<br><img src="/uploads/algorithm/searching/st-api.png" alt="stAPI"></p><a id="more"></a><h2 id="无序链表中的顺序查找"><a href="#无序链表中的顺序查找" class="headerlink" title="无序链表中的顺序查找"></a>无序链表中的顺序查找</h2><p>符号表中使用的数据结构的一个简单选择是链表，每个结点存储一个键值对，<code>get()</code>的实现即为遍历链表，用<code>equals()</code>方法比较需被查找的键和每个结点中的键，如果成功匹配就返回相应的值，否则返回<code>null</code>，<code>put()</code>的实现也是遍历链表，用<code>equals()</code>方法比较需被查找的键和每个结点中的键，如果匹配成功就用第二个参数指定的值更新和该键关联的值，否则就用给定的键值对创建一个新的结点并将其插入到链表的开头，这种方法也被称为<strong>顺序查找</strong>：在查找中一个一个地顺序遍历符号表中的所有键并使用<code>equals()</code>方法来寻找与被查找的键匹配的键。<br><img src="/uploads/algorithm/searching/sequential-search.png" alt="sequential-search"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrdios.competencymatrix.algorithm.searching;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺序查找(基于无序链表)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> huxiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017-04-13 10:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearchST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;  <span class="comment">// 链表首结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;       <span class="comment">// 键值对数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表结点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Key key;</span><br><span class="line">        <span class="keyword">private</span> Value value;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回链表中的键值对数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> number of key-value pairs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找给定的键，找到则更新值，否则新建结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 命中？更新旧值</span></span><br><span class="line">        <span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.equals(x.key)) &#123;</span><br><span class="line">                x.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未命中？新建结点</span></span><br><span class="line">        first = <span class="keyword">new</span> Node(key, value, first);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找给定的键，返回相关联的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key search key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value for the key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.equals(x.key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> x.value; <span class="comment">// 命中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="comment">// 未命中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有序数组中的二分查找"><a href="#有序数组中的二分查找" class="headerlink" title="有序数组中的二分查找"></a>有序数组中的二分查找</h2><p>有序符号表API的完整实现使用的数据结构是一对平行的数组，一个存储键一个存储值，算法<code>BinarySearchST</code>可以保证数组中<code>Comparable</code>类型的键有序，然后使用数组的索引来高效地实现<code>get()</code>和其它操作。</p><p>实现的核心是<code>rank()</code>方法，它返回表中小于给定键的键的数量，对于<code>get()</code>方法，只要给定的键存在于表中，<code>rank()</code>方法就能精确地告诉我们哪里能够找到它（如果找不到，那它肯定就不在表中了）。</p><p>对于<code>put()</code>方法，只要给定的键存在于表中，<code>rank()</code>方法就能精确地告诉我们到哪里去更新它的值，以及键不存在表中时将键存到表的何处，我们将所有更大的键向后移动一格来腾出位置（从后向前移动）并将给定的键值对分别插入到各自数组中的合适位置</p><p>使用基于有序数组的符号表实现的索引用例的轨迹如下图：</p><p><img src="/uploads/algorithm/searching/binary-search.png" alt="binary-search"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrdios.competencymatrix.algorithm.searching;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> huxiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017-04-13 13:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] vals;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchST</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">        vals = (Value[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            vals[i] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt; i; j--) &#123;</span><br><span class="line">            keys[j] = keys[j - <span class="number">1</span>];</span><br><span class="line">            vals[j] = vals[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i] = key;</span><br><span class="line">        vals[i] = val;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> vals[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cmp = key.compareTo(keys[mid]);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;定义：符号表是一种存储键值对的数据结构，支持两种操作：插入（&lt;code&gt;put&lt;/code&gt;），即将一组新的键值对存入表中；查找（&lt;code&gt;get&lt;/code&gt;），即根据给定的键得到相应的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的泛型符号表的API如下图所示：&lt;br&gt;&lt;img src=&quot;/uploads/algorithm/searching/st-api.png&quot; alt=&quot;stAPI&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://balderdasher.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://balderdasher.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法第二章-排序</title>
    <link href="https://balderdasher.github.io/2018/03/07/algorithm-sorting/"/>
    <id>https://balderdasher.github.io/2018/03/07/algorithm-sorting/</id>
    <published>2018-03-07T01:50:08.000Z</published>
    <updated>2021-09-29T06:04:29.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法类模板类"><a href="#排序算法类模板类" class="headerlink" title="排序算法类模板类"></a>排序算法类模板类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrdios.competencymatrix.algorithm.sorting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.In;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序模板类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> huxiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017-04-06 9:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a an array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sorting code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个元素的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个元素的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断数组是否已排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试数组元素是否有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[i], a[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test case</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] a = <span class="keyword">new</span> In().readAllStrings();</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>选择排序的算法是这样的：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和它自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法就叫<code>选择排序</code>，因为它不断地选择剩余元素之中的最小者。</p></blockquote><p>选择排序中每次交换都能排定一个元素，因此交换的总次数就是<code>N</code>，所以算法的时间效率取决于比较的次数。</p><p>对于长度为<em>N</em>的数组，选择排序需要大约<code>N²/2</code>次比较和<code>N</code>次交换。</p><p>交换排序的特点：</p><ul><li><strong>运行时间和输入无关</strong>：这意味着一个已经排好序的数组和一个乱序的数组使用此种排序算法花费的时间将会一样长</li><li><strong>数据移动是最少的</strong>：每次交换都会改变两个数组元素的值，因此选择排序用了<em>N</em>次交换————交换次数和数组的大小是线性关系。</li></ul><p>排序代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 升序排列</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;   <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">// 将a[i]和a[i+1..N]中最小的元素交换</span></span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(a[j], a[min])) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// less()等方法同Example模板类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法将<code>第i小</code>的元素放到<code>a[i]</code>中。数组的第<code>i</code>个位置的左边是<code>i</code>个最小的元素并且它们不会再被访问。<br><img src="/uploads/algorithm/sorting/Selection.png" alt="Selection"></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入排序就像是平时我们打扑克的时候理牌的动作，将每一张牌都插入到其他已经有序的牌中的适当位置，在计算机程序中，为了给要插入的元素腾出空间，需要将其与所有元素在插入之前都向右移动一位，这种算法就叫做<code>插入排序</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与选择排序一样，当前索引左边的所有元素都是有序的，但他们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和选择排序不同的一点是，插入排序所需的时间取决于输入元素的初始顺序，例如对一个很大的且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。</p></blockquote><p>对于随机排列的长度为<em>N</em>的主键不重复的数组，平均情况下插入排序需要<code>~N²/4</code>次比较以及<code>~N²/4次交换</code>。最坏情况下需要<code>~N²/2</code>次比较和<code>~N²/2</code>次交换，最好情况下需要<code>N-1</code>次比较和<code>0</code>次交换。</p><p>排序代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 升序排列</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;   <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">// 将a[i]插入到a[i-1]、a[i-1]、a[i-3]..之中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j - <span class="number">1</span>]); j--) &#123;</span><br><span class="line">                exch(a, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// less()等方法同Example模板类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>0</code>到<code>N-1</code>之间的每一个<code>i</code>，将<code>a[i]</code>与<code>a[i-1]</code>中比它小的所有元素依次有序地交换。在索引<code>i</code>由左向右变化的过程中，它左侧的元素总是有序的，所以当<code>i</code>到达数组的右端时排序就完成了。<br><img src="/uploads/algorithm/sorting/Insertion.png" alt="insertion"></p><h3 id="插入排序的适用场景（部分有序的数组）"><a href="#插入排序的适用场景（部分有序的数组）" class="headerlink" title="插入排序的适用场景（部分有序的数组）"></a>插入排序的适用场景（部分有序的数组）</h3><p>插入排序对部分有序的数组排序很有效，而选择排序则不然，事实上，当倒置的数量很少时，插入排序很可能比其它任何排序算法都要快。所谓的部分有序包括以下几种情况：</p><ul><li>数组中每个元素距离它的最终位置都不远</li><li>一个有序的大数组接一个小数组</li><li>数组中只有几个元素的位置不正确</li></ul><p><strong>小结：</strong> 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较此数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。</p><h3 id="选择排序和插入排序的比较"><a href="#选择排序和插入排序的比较" class="headerlink" title="选择排序和插入排序的比较"></a>选择排序和插入排序的比较</h3><blockquote><p>对于随机排序的无重复主键的数据，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。</p></blockquote><p>以下的<code>SortCompare</code>类用于比较两种排序算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrdios.competencymatrix.algorithm.sorting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mrdios.competencymatrix.algorithm.fundamentals.AnalysisOfAlgorithm.Stopwatch;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较排序算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> huxiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017-04-06 15:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortCompare</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 各种排序算法所花费的时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alg 排序算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a   待排序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 排序花费时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">time</span><span class="params">(String alg, Double[] a)</span> </span>&#123;</span><br><span class="line">        Stopwatch timer = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">"Insertion"</span>))</span><br><span class="line">            Insertion.sort(a);</span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">"Selection"</span>))</span><br><span class="line">            Selection.sort(a);</span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">"Shell"</span>)) &#123;</span><br><span class="line">            Shell.sort(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">"Merge"</span>)) &#123;</span><br><span class="line">            Merge.sort(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">"Quick"</span>)) &#123;</span><br><span class="line">            Quick.sort(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">"Heap"</span>)) &#123;</span><br><span class="line">            Heap.sort(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timer.elapsedTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0.0到1.0之间的随机数组排序时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alg 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> N   数组长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> T   重复次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 使用算法将T个长度为N的数组排序所花费的时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">timeRandomInput</span><span class="params">(String alg, <span class="keyword">int</span> N, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用算法将T个长度为N的数组排序</span></span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>d;</span><br><span class="line">        Double[] a = <span class="keyword">new</span> Double[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; T; t++) &#123;</span><br><span class="line">            <span class="comment">// 进行一次测试（生成一个数组并排序）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                a[i] = StdRandom.uniform();</span><br><span class="line">            &#125;</span><br><span class="line">            total += time(alg, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java SortCompare Insertion Selection 1000 300</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String alg1 = args[<span class="number">0</span>];</span><br><span class="line">        String alg2 = args[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> N = Integer.parseInt(args[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">int</span> T = Integer.parseInt(args[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">double</span> t1 = timeRandomInput(alg1, N, T);<span class="comment">// 算法1的总时间</span></span><br><span class="line">        <span class="keyword">double</span> t2 = timeRandomInput(alg2, N, T);<span class="comment">// 算法2的总时间</span></span><br><span class="line">        StdOut.printf(<span class="string">"For %d random Doubles\n  %s is"</span>, N, alg1);</span><br><span class="line">        StdOut.printf(<span class="string">" %.1f times faster than %s\n"</span>, t2 / t1, alg2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>希尔排序的思想是使数组中任意间隔为<code>h</code>的元素都是有序的。这样的数组被称为<code>h有序数组</code>。换言之，一个<code>h有序数组</code>就是<code>h</code>个互相独立的有序数组编织在一起组成的一个数组（如下图），在进行排序时，如果h很大，我们就能将元素移动到很远的地方，为实现<code>更小的h有序</code>创造方便。用这种方式，对任意以<code>1</code>结尾的h序列，我们都能够将数组排序，这就是希尔排序。<br><img src="/uploads/algorithm/sorting/h-sorted.png" alt="h-sorted"></p></blockquote><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将a[]按升序排列</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) &#123;</span><br><span class="line">            h = <span class="number">3</span> * h + <span class="number">1</span>; <span class="comment">// 1,4,13,40,121,364,1093,...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="comment">// 将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123;</span><br><span class="line">                    exch(a, j, j - h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序轨迹图：<br><img src="/uploads/algorithm/sorting/Shell.png" alt="shell"></p><p><strong>小结</strong>：使用递增序列1,4,13,40,121,364…的希尔排序所需的比较此数不会超出<em>N</em>的若干倍乘以递增序列的长度。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来，归并排序最吸引人的性质是它能够保证将任意长度为<em>N</em>的数组排序所需要的时间和<em>NlogN</em>成正比；它的主要缺点则是它所需的额外空间和<em>N</em>成正比，如下为简单的归并排序示意图：<br><img src="/uploads/algorithm/sorting/mergesort-overview.png" alt="mergesort-overview"></p></blockquote><h3 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h3><blockquote><p>原地归并的方法就是先将数组的前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要额外的空间的排序方法。<br>原地归并的方法签名<code>merge(a,lo,mid,hi)</code>,它会将子数组<code>a[lo..mid]</code>和<code>a[mid+1..hi]</code>归并成一个有序的数组并将结果存放在<code>a[lo..hi]</code>中，如下的代码就实现了这种归并，它借助一个辅助数组把涉及到的元素复制到其中，再把归并的结果放回原数组中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原地归并的抽象方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将a[1o..mid] 和 a[mid+1..hi] 归并</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将a[1o..hi]复制到aux[lo..hi]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 归并回到a[lo..hi]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            a[k] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;</span><br><span class="line">            a[k] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) &#123;</span><br><span class="line">            a[k] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法先将所有元素复制到<code>aux[]</code>中，然后再归并回<code>a[]</code>中，方法在归并时（第二个<code>for循环</code>）进行了4个条件判断：左半边用尽（取右半边元素）、右半边用尽（取左半边元素）、右半边的当前元素小于左半边的当前元素（取右半边的元素）以及右半边的当前元素大于等于左半边的当前元素（取左半边的元素）。<br><img src="/uploads/algorithm/sorting/merge.png" alt="merge"></p><h3 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自顶向下的归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">    sortUB(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortUB</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数组a[lo..hi]排序</span></span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    sortUB(a, lo, mid);       <span class="comment">// 将左半边排序</span></span><br><span class="line">    sortUB(a, mid + <span class="number">1</span>, hi);<span class="comment">// 将右半边排序</span></span><br><span class="line">    merge(a, lo, mid, hi);  <span class="comment">// 归并结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/uploads/algorithm/sorting/mergesortTD.png" alt="mergesortTD"></p><h3 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自底向上的归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortBU</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">0</span>; sz &lt; N; sz = sz + sz) &#123;<span class="comment">// sz子数组大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N - sz; lo += sz + sz) &#123;<span class="comment">// lo:子数组索引</span></span><br><span class="line">            merge(a, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/uploads/algorithm/sorting/mergesortBU.png" alt="mergesortBU.png"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="/uploads/algorithm/sorting/quicksort-overview.png" alt="quicksort-overview"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        StdRandom.shuffle(a);   <span class="comment">// 打乱数组消除对输入的依赖</span></span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = partition(a, lo, hi); <span class="comment">// 切分</span></span><br><span class="line">        sort(a, lo, j - <span class="number">1</span>);        <span class="comment">// 将左半部分a[lo ... j-1]排序</span></span><br><span class="line">        sort(a, j + <span class="number">1</span>, hi);        <span class="comment">// 将右半部分a[j+1 ... hi]排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将数组切分为a[lo..i-1],a[i],a[i+1..hi]</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>; <span class="comment">// 左右扫描指针</span></span><br><span class="line">        Comparable v = a[lo];   <span class="comment">// 切分元素</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 扫描左右，检查扫描是否结束并交换元素</span></span><br><span class="line">            <span class="keyword">while</span> (less(a[++i], v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == hi) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (less(v, a[--j])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == lo) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, lo, j); <span class="comment">// 将v=a[j]放入正确的位置</span></span><br><span class="line">        <span class="keyword">return</span> j;       <span class="comment">// a[lo..j-1] &lt;=a[j] &lt;=a[j+1..hi] 达成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] nums = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        System.out.print(<span class="string">"排序结果："</span>);</span><br><span class="line">        show(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序的关键在于切分，切分使数组满足以下三个条件：</p><ul><li>对于某个<code>j</code>,<code>a[j]</code>已经排定</li><li><code>a[lo]</code>到<code>a[j-1]</code>中的所有元素都不大于<code>a[j]</code></li><li><code>a[j+1]</code>到<code>a[hi]</code>中的所有元素都不小于<code>a[j]</code></li></ul><p><img src="/uploads/algorithm/sorting/partitioning.png" alt="partitioning"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><blockquote><p>优先队列是一种<strong>抽象数据类型</strong>，表示了一组值和对这些值的操作，优先队列最重要的操作就是<code>删除最大元素和插入元素</code>。</p></blockquote><h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><p>数据结构<code>二叉堆</code>能够很好地实现优先队列的基本操作</p><blockquote><p>定义：当一棵二叉树的每个节点都大于等于它的两个子节点时，它被称为堆有序。二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。根节点是堆有序的二叉树中的最大节点。</p></blockquote><p>在一个<code>二叉堆</code>（简称堆）中，位置<code>k</code>的结点的父结点的位置为<code>k/2</code>，而它的两个子结点的位置分别是<code>2k</code>和<code>2k+1</code>，这样在不使用指针的情况下我们也可以通过计算数组的索引在树中上下移动：从<code>a[k]</code>向上一层就令<code>k</code>等于<code>k/2</code>，向下一层则令<code>k</code>等于<code>2k</code>或<code>2k+1</code>。</p><p><img src="/uploads/algorithm/sorting/heap-representations.png" alt="heap-representations"></p><p>堆的算法采用长度为<code>N+1</code>的私有数组<code>pq[]</code>来表示一个大小为<code>N</code>的堆，不使用<code>pq[0]</code>,对元素放在<code>pq[1]</code>至<code>pq[N]</code>中，在堆的有序化过程中会遇到两种情况：当某个结点的优先级上升（或是在堆底加入一个新的元素）时，需要<strong>由下至上</strong>恢复堆的顺序。当某个结点的优先级下降（例如将根节点替换为一个较小的元素）时，需要<strong>由上至下</strong>恢复堆的顺序，这两种情况称为<strong>由下至上的堆有序化（上浮）</strong><code>swim()</code>和<strong>由上至下的堆有序化（下沉）</strong><code>sink()</code>,如下图所示：</p><p><img src="/uploads/algorithm/sorting/SwimAndSink.png" alt="SwimAndSink"></p><p>所以，在堆中插入和删除最大元素的过程如下：</p><ul><li><strong>插入元素</strong>，将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置</li><li><strong>删除最大元素</strong>，从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置。</li></ul><p><img src="/uploads/algorithm/sorting/heap-ops.png" alt="heap-ops"></p><p>一个基于堆的完全二叉树表示的优先队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrdios.competencymatrix.algorithm.sorting;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> huxiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017-04-11 10:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key[] pq;       <span class="comment">// 基于堆的完全二叉树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;      <span class="comment">// 存储于pq[0..N]中，pq[0]没有使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个优先队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个最大容量为max的优先队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxN 最大容量值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> maxN)</span> </span>&#123;</span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> Comparable[maxN + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用a[]中的元素创建一个优先队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a an array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(Key[] a)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队列是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回优先队列中的元素个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> element count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v an element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key v)</span> </span>&#123;</span><br><span class="line">        pq[++N] = v;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回最大元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除并返回最大元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Key max = max();  <span class="comment">// 从根节点得到最大元素</span></span><br><span class="line">        exch(<span class="number">1</span>, N--);   <span class="comment">// 将其和最后一个节点交换</span></span><br><span class="line">        pq[N + <span class="number">1</span>] = <span class="keyword">null</span>; <span class="comment">// 防止越界</span></span><br><span class="line">        sink(<span class="number">1</span>);        <span class="comment">// 恢复堆的有序性</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Key t = pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由下至上的堆有序变化（上浮）的实现</span></span><br><span class="line"><span class="comment">     * k节点的父节点的位置是k/2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">            exch(k / <span class="number">2</span>, k);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由上至下的堆有序变化（下沉）的实现</span></span><br><span class="line"><span class="comment">     * k节点的子节点位于2k和2k+1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j + <span class="number">1</span>)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!less(k, j)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] nums = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        MaxPQ&lt;Integer&gt; pq = <span class="keyword">new</span> MaxPQ&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        System.out.println(pq.isEmpty());</span><br><span class="line">        <span class="keyword">for</span> (Integer i : nums) &#123;</span><br><span class="line">            pq.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(pq.max());</span><br><span class="line">        pq.delMax();</span><br><span class="line">        System.out.println(pq.max());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以把任意优先队列变成一种排序方法，用基于堆的优先队列做此种排序就出现了一种全新的排序方法——<code>堆排序</code>，<br>堆排序可以分为两个阶段。<strong>堆的构造阶段</strong>和<strong>下沉排序阶段</strong>。在堆的构造阶段中，我们将原始数组重新组织安排进一个堆中；然后在下沉排序阶段。我们从堆中按<code>递减顺序</code>取出所有元素并得到排序结果。</p></blockquote><h3 id="堆的构造"><a href="#堆的构造" class="headerlink" title="堆的构造"></a>堆的构造</h3><p>用下沉操作由<em>N</em>个元素构造堆只需少于<em>2N</em>次比较以及少于<em>N</em>次交换</p><p><img src="/uploads/algorithm/sorting/heapsort-trace.png" alt="heapsort-trace"></p><p>堆排序轨迹图：</p><p><img src="/uploads/algorithm/sorting/heapsort.png" alt="heapsort"></p><p>堆排序算法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrdios.competencymatrix.algorithm.sorting;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序--两个阶段</span></span><br><span class="line"><span class="comment"> * 1、构造堆</span></span><br><span class="line"><span class="comment"> * 2、下沉排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> huxiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017-04-11 15:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="comment">// 构造堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = n / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">            sink(a, k, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下沉排序</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            exch(a, <span class="number">1</span>, n--);</span><br><span class="line">            sink(a, <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由上至下的堆有序变化（下沉）的实现</span></span><br><span class="line"><span class="comment">     * k节点的子节点位于2k和2k+1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pq an array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k  扫描开始的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n  结束位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n &amp;&amp; less(pq, j, j + <span class="number">1</span>)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!less(pq, k, j)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(pq, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i - <span class="number">1</span>].compareTo(pq[j - <span class="number">1</span>]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable swap = a[i - <span class="number">1</span>];</span><br><span class="line">        a[i - <span class="number">1</span>] = a[j - <span class="number">1</span>];</span><br><span class="line">        a[j - <span class="number">1</span>] = swap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何选择排序算法"><a href="#如何选择排序算法" class="headerlink" title="如何选择排序算法"></a>如何选择排序算法</h2><p>各种排序算法的性能特点如下图所示：</p><p><img src="/uploads/algorithm/sorting/SortsTable.png" alt="SortsTable"></p><p>由上表可得出结论：<strong>快速排序时最快的通用排序算法</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序算法类模板类&quot;&gt;&lt;a href=&quot;#排序算法类模板类&quot; class=&quot;headerlink&quot; title=&quot;排序算法类模板类&quot;&gt;&lt;/a&gt;排序算法类模板类&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; com.mrdios.competencymatrix.algorithm.sorting;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; edu.princeton.cs.algs4.In;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 排序模板类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; huxiong&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@date&lt;/span&gt; 2017-04-06 9:04&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Example&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 排序算法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; a an array&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Comparable[] a)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// sorting code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 比较两个元素的大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;less&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Comparable v, Comparable w)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; v.compareTo(w) &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 交换两个元素的位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;exch&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Comparable[] a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Comparable t = a[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[i] = a[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[j] = t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 打印元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Comparable[] a)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; a.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.print(a[i] + &lt;span class=&quot;string&quot;&gt;&quot; &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 判断数组是否已排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isSorted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Comparable[] a)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 测试数组元素是否有序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; a.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (less(a[i], a[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// test case&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String[] a = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; In().readAllStrings();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sort(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isSorted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        show(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="https://balderdasher.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://balderdasher.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法第一章-算法基础之背包、栈和队列</title>
    <link href="https://balderdasher.github.io/2018/03/06/algorithm-fundamentals-bag-stack-and-queue/"/>
    <id>https://balderdasher.github.io/2018/03/06/algorithm-fundamentals-bag-stack-and-queue/</id>
    <published>2018-03-06T06:36:32.000Z</published>
    <updated>2021-09-29T06:04:29.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><img src="/uploads/algorithm/fundations/Bag&amp;Queue&amp;Stack&#39;sApi.png" alt="Bag&amp;Queue&amp;Stack&#39;sApi"></p><a id="more"></a><h2 id="背包（Bag）"><a href="#背包（Bag）" class="headerlink" title="背包（Bag）"></a>背包（Bag）</h2><blockquote><p><strong>背包</strong>是一种不支持从中删除元素的集合数据类型——它的作用就是帮助收集元素并迭代所有收集到的元素（也可以检查背包是否为空或者获取背包中元素的数量），迭代的顺序不确定。</p></blockquote><p>背包的理解可想象为一个弹子球收集爱好者，他收集弹子球放进一个背包里，一次一个，并且会不时在所有的弹子球中寻找一个拥有某种特点的弹子球，如下图所示：</p><p><img src="/uploads/algorithm/fundations/Bag.png" alt="Bag"></p><p>编程实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;Item&gt; first; <span class="comment">// 背包开始节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;   <span class="comment">// 背包中的元素数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表结构帮助类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Item item;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;Item&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create an empty bag</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add an item</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        Node&lt;Item&gt; oldFirst = first;</span><br><span class="line">        first = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        first.item = item;</span><br><span class="line">        first.next = oldFirst;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * is the bag empty?</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * number of items in the bag</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Item&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Node&lt;Item&gt; current = first;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> current != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                &#125;</span><br><span class="line">                Item item = current.item;</span><br><span class="line">                current = current.next;</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bag&lt;String&gt; bag = <span class="keyword">new</span> Bag&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            bag.add(<span class="string">"Str"</span> + (i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"the bag size: "</span> + bag.size());</span><br><span class="line">        <span class="keyword">for</span> (String str : bag) &#123;</span><br><span class="line">            System.out.print(str + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote><p>队列是一种基于<em>先进先出</em>（<code>FIFO</code>）策略的集合类型，比如日常生活中的排队就是这种策略，元素的处理顺序就是它们被添加到队列中的顺序。</p></blockquote><p><img src="/uploads/algorithm/fundations/QueueExample.png" alt="QueueExample"></p><p>一种实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Item item;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create an empty queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * is the queue empty?</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if queue is empty otherwise false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of emelments of in the queue</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of emelments of in the queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add an item</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item an element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        Node oldLast = last;</span><br><span class="line">        last = <span class="keyword">new</span> Node();</span><br><span class="line">        last.item = item;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            first = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oldLast.next = last;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除最近添加的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = first;</span><br><span class="line">        first = first.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> node.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node current;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.current = first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">            Item item = current.item;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String s = <span class="string">"str"</span> + (i + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"Enqueuing "</span> + s);</span><br><span class="line">            queue.enqueue(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"size of queue = "</span> + queue.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Dequeuing "</span> + queue.dequeue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"size of queue = "</span> + queue.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><blockquote><p>栈是一种基于<em>后进先出</em>（LIFO）策略的集合类型，新加入的元素总是位于栈顶，最先入栈的元素位于栈底，取用元素时总是弹出栈顶元素，迭代栈中的元素时，元素的处理顺序和它们被压入栈的顺序正好相反。</p></blockquote><p><img src="/uploads/algorithm/fundations/StackOpt.png" alt="栈的操作"></p><p>一个实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node top; <span class="comment">// 栈顶元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// 元素数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Item item;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化一个空栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回栈中元素数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压入栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 压入元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        Node oldTop = top;</span><br><span class="line">        top = <span class="keyword">new</span> Node();</span><br><span class="line">        top.item = item;</span><br><span class="line">        top.next = oldTop;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 栈顶元素 top</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node oldTop = top;</span><br><span class="line">        top = top.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> oldTop.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node current = top;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">            Item item = current.item;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String s = <span class="string">"str"</span> + (i + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"Stack push "</span> + s);</span><br><span class="line">            stack.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String s : stack) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"size of stack = "</span> + stack.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Stack pop "</span> + stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"size of stack = "</span> + stack.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合数据类型性能最佳的实现标准"><a href="#集合数据类型性能最佳的实现标准" class="headerlink" title="集合数据类型性能最佳的实现标准"></a>集合数据类型性能最佳的实现标准</h2><ul><li>每项操作的用时都与集合大小无关</li><li>空间需求总是不超过集合大小乘以一个常数</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote><p><strong>定义</strong>：链表是一种递归的数据结构，它或者为空（<code>null</code>），或者是指向一个节点（<code>node</code>）的引用，该节点含有一个泛型的元素和一个指向另一条链表的引用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/uploads/algorithm/fundations/Bag&amp;amp;Queue&amp;amp;Stack&amp;#39;sApi.png&quot; alt=&quot;Bag&amp;amp;Queue&amp;amp;Stack&amp;#39;sApi&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://balderdasher.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://balderdasher.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法第一章-算法基础之基础编程模型</title>
    <link href="https://balderdasher.github.io/2018/03/06/algorithm-fundamentals-base-program-model/"/>
    <id>https://balderdasher.github.io/2018/03/06/algorithm-fundamentals-base-program-model/</id>
    <published>2018-03-06T01:12:32.000Z</published>
    <updated>2021-09-29T06:04:29.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法是什么"><a href="#算法是什么" class="headerlink" title="算法是什么"></a>算法是什么</h2><blockquote><p>算法，简而言之就是解决某个问题的方法。在计算机科学领域使用<code>算法</code>这个词来描述一种<strong>有限</strong>、<strong>确定</strong>、<strong>有效</strong>并<strong>适合用计算机程序来实现</strong>的解决问题的方法。算法是计算机科学的基础，是这个领域的核心。</p></blockquote><h2 id="如何定义一个算法"><a href="#如何定义一个算法" class="headerlink" title="如何定义一个算法"></a>如何定义一个算法</h2><ul><li>用自然语言描述解决某个问题的过程</li><li>或编写一段程序来实现这个过程</li></ul><p>如2300多年前的<code>欧几里德算法</code>，它用于找到两个数的最大公约数：</p><p>自然语言描述</p><blockquote><p>计算两个非负整数<em>p</em>和<em>q</em>的最大公约数：若<em>q</em>是0，则最大公约数为<em>p</em>。否则将<em>p</em>除以<em>q</em>得到余数<em>r</em>，<em>p</em>和<em>q</em>的最大公约数即为<em>q</em>和<em>r</em>的最大公约数。</p></blockquote><p>java语言描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求两个非负整数的最大公约数的计算机程序算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 非负整数p</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> q 非负整数q</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> p和q的最大公约数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span> || q &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the param number must ge 0."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = p % q;</span><br><span class="line">    <span class="keyword">return</span> gcd(q, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法与数据结构的关系"><a href="#算法与数据结构的关系" class="headerlink" title="算法与数据结构的关系"></a>算法与数据结构的关系</h3><blockquote><p>大多数算法都需要适当地组织数据，由此产生了<code>数据结构</code>，数据结构可以说是算法的副产品或结果，简单的算法也许会产生复杂的数据结构，复杂的算法也可能只需要简单的数据结构。数据结构与算法密不可分。</p></blockquote><h3 id="编写递归代码时应该注意什么"><a href="#编写递归代码时应该注意什么" class="headerlink" title="编写递归代码时应该注意什么"></a>编写递归代码时应该注意什么</h3><ul><li>递归总有一个<code>最简单的情况</code>———方法的第一条语句总是包含一个<code>return</code>语句</li><li>递归调用总是去尝试解决一个<code>规模更小</code>的子问题，这样递归才能收敛到最简单的情况，如以下代码中，第四个参数和第三个参数的差值一直在缩小。</li><li>递归调用的父问题和尝试解决的子问题之间不应该有交集，如以下代码中两个子问题各自操作的数组部分是不同的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rank(key, a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果a中存在key，它的索引不会小于lo且不会大于hi</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; a[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> rank(key, a, lo, mid - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> rank(key, a, mid + <span class="number">1</span>, hi);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="基础算法：二分查找"><a href="#基础算法：二分查找" class="headerlink" title="基础算法：二分查找"></a>基础算法：二分查找</h3><ul><li>算法示意图：<br><img src="/uploads/algorithm/fundations/binary-search.png" alt="binary-search"></li><li>算法程序：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找（折半查找）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a   整数数组，必须是经过排序的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key search key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 找到返回key在a中的下标否则-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组的起始索引为什么是0而不是1？"><a href="#数组的起始索引为什么是0而不是1？" class="headerlink" title="数组的起始索引为什么是0而不是1？"></a>数组的起始索引为什么是0而不是1？</h4><p>因为在机器语言中，计算一个数组元素的地址需要将数组的起始地址加上该元素的索引。所以将起始索引设为1的话要么会浪费数组的第一个元素所占的空间，要么会花费额外的时间来将索引减1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法是什么&quot;&gt;&lt;a href=&quot;#算法是什么&quot; class=&quot;headerlink&quot; title=&quot;算法是什么&quot;&gt;&lt;/a&gt;算法是什么&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;算法，简而言之就是解决某个问题的方法。在计算机科学领域使用&lt;code&gt;算法&lt;/code&gt;这
      
    
    </summary>
    
      <category term="算法" scheme="https://balderdasher.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://balderdasher.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HashMap那点事</title>
    <link href="https://balderdasher.github.io/2018/01/03/things-about-hashmap/"/>
    <id>https://balderdasher.github.io/2018/01/03/things-about-hashmap/</id>
    <published>2018-01-03T07:52:57.000Z</published>
    <updated>2021-09-29T06:04:29.564Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/notes/HashMap.png" alt="HashMap继承机构"><br><a id="more"></a></p><p>HashMap是基于哈希表的 <code>Map</code> 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><h2 id="HashMap的数据结构是什么？"><a href="#HashMap的数据结构是什么？" class="headerlink" title="HashMap的数据结构是什么？"></a>HashMap的数据结构是什么？</h2><p>HashMap底层是<em>链表散列</em>的数据结构，即数组和链表的结合体，底层是一个存放<code>Entry</code>的数组，<code>Entry</code>又可能是链表中的一个结点，其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * The table, resized as necessary. Length MUST Always be a power of two. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">transient</span> Entry[] table;  </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> K key;  </span><br><span class="line">    V value;  </span><br><span class="line">    Entry&lt;K,V&gt; next;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  </span><br><span class="line">    ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/uploads/notes/HashMap-data-structure.jpg" alt="HashMap数据结构"></p><h2 id="影响HashMap性能的参数是什么？"><a href="#影响HashMap性能的参数是什么？" class="headerlink" title="影响HashMap性能的参数是什么？"></a>影响HashMap性能的参数是什么？</h2><p><code>HashMap</code> 的实例有两个参数影响其性能：<em>初始容量</em> 和<em>加载因子</em>。<strong>容量</strong> 是哈希表中桶的数量(数组的长度)，初始容量只是哈希表在创建时的容量。<em>加载因子</em> 是哈希表在其容量自动增加（扩容）之前可以达到多满的一种尺度。当哈希表中的条目数超出了<strong>加载因子与当前容量的乘积</strong>时，则要对该哈希表进行 <code>rehash</code>(扩容) 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。</p><h2 id="HashMap的容量为什么一定要是2的次幂？"><a href="#HashMap的容量为什么一定要是2的次幂？" class="headerlink" title="HashMap的容量为什么一定要是2的次幂？"></a>HashMap的容量为什么一定要是2的次幂？</h2><p>HashMap的容量即底层数组的长度<code>length</code>,<code>length</code>将被用于计算元素将被放入数组的位置，计算方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>取模运算<code>h % length</code>确保元素的分布相对是比较均匀的，当<code>length</code>是2的次幂时，<code>h &amp; (length-1)</code>运算等价于取模运算<code>h % length</code>，但是<code>&amp;</code>（与）运算比<code>%</code>（取模）运算具有更高的效率。同时，当length为2的次幂时，通过计算可以是元素获得更均匀的分布。</p><p>假设数组长度为15和16，重新计算后的hash分别为8和9，那么通过<code>indexFor</code>散列之后的元素分布结果如下：</p><table><thead><tr><th>table.length</th><th>h &amp; (table.length-1)</th><th>hash</th><th>table.length-1</th><th>index</th></tr></thead><tbody><tr><td>15</td><td>8 &amp; (15-1)</td><td>1000</td><td>1110</td><td>1000(8)</td></tr><tr><td>15</td><td>9 &amp; (15-1)</td><td>1001</td><td>1110</td><td>1000(8)</td></tr><tr><td>16</td><td>8 &amp; (16-1)</td><td>1000</td><td>1111</td><td>1000(8)</td></tr><tr><td>16</td><td>9 &amp; (16-1)</td><td>1001</td><td>1111</td><td>1001(9)</td></tr></tbody></table><p>从上表中可以看出，当length等于15时，不同的hash值8和9都被定位到了数组中的同一个位置8，产生了碰撞，而且此时的运算结果最后一位永远是0，所以0001，,011,1001,1011，0111,1101等位置将永远都不能存放元素了，空间浪费很大，也进一步增加了碰撞的几率，降低了查询效率。</p><p>相反，当数组长度为16时，参与运算的length-1的二进制数每个位的值都为1，使得在低位与时，得到的值和原hash的低位相同，因此不同的hash值8和9被定位到了不同的位置上。因此当数组长度为2的次幂时，不同的key被定位到相同index的几率较小，数据在数组上的分布比较均匀，使得HashMap的查询效率得以提高。</p><h2 id="如何处理大量的hash碰撞攻击？"><a href="#如何处理大量的hash碰撞攻击？" class="headerlink" title="如何处理大量的hash碰撞攻击？"></a>如何处理大量的hash碰撞攻击？</h2><p>此种攻击最常见的是POST数据攻击，构造一个含有大量碰撞key的post请求达到攻击的目的。</p><ul><li>控制post数据的大小</li><li>限制http请求body的大小和参数的数量</li><li>限制每个桶链表的最大长度</li><li>使用其它数据结构如红黑树取代链表组织碰撞哈希（并不解决哈希碰撞，只是减轻攻击影响，将N个数据的操作时间从O(N^2)降至O(NlogN)，代价是普通情况下接近O(1)的操作均变为O(logN)）</li></ul><h2 id="jdk8中HashMap实现有什么变化"><a href="#jdk8中HashMap实现有什么变化" class="headerlink" title="jdk8中HashMap实现有什么变化"></a>jdk8中HashMap实现有什么变化</h2><p>jdk8中<code>HashMap</code>实现的底层结构有所变化，当桶上的链表长度大于8时，链表将转变为红黑树结构，一定程度上减轻了hash碰撞攻击的影响，优化了元素的查找效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/notes/HashMap.png&quot; alt=&quot;HashMap继承机构&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://balderdasher.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://balderdasher.github.io/tags/java/"/>
    
      <category term="集合" scheme="https://balderdasher.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList那点事</title>
    <link href="https://balderdasher.github.io/2017/12/29/things-about-linkedlist/"/>
    <id>https://balderdasher.github.io/2017/12/29/things-about-linkedlist/</id>
    <published>2017-12-29T06:59:33.000Z</published>
    <updated>2021-09-29T06:04:29.566Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/notes/LinkedList.png" alt="LinkedList继承结构"></p><a id="more"></a><p>LinkedList是<code>List</code>接口的双向链表实现，允许容纳包括null在内的所有引用类型对象的元素，对元素的获取始终需要从链表头开始遍历直到链表尾部，所以<code>LinkedList</code>是顺序访问类型的容器，基于数组的<code>ArrayList</code>则是通过下标就可以直接定位访问元素的随机访问，这点从类的继承结构中也可以看出：</p><ul><li>ArrayList实现了<code>RandomAccess</code>接口，提供随机访问的能力</li><li>LinkedList则继承了<code>AbstractSequentialList</code>,提供顺序访问的能力</li><li>LinkedList同时还实现了<code>Deque</code>接口，可以当做双端队列使用</li></ul><h2 id="LinkedList底层数据结构是什么？"><a href="#LinkedList底层数据结构是什么？" class="headerlink" title="LinkedList底层数据结构是什么？"></a>LinkedList底层数据结构是什么？</h2><p>如同其名字一样，LinkedList的实现基于<strong>双向链表</strong>，所谓的双向链表是针对单向链表而言，单向链表中的一个节点只有指向下一个节点的链，而双向链表中的每个节点都有两条链，一条指向它的前驱节点，一条指向它的后继节点。<br><img src="/uploads/notes/double-link.png" alt="双向链表"></p><p>如上图所示，添加元素时其实就是新增了链表的一个结点，结点中的<code>item</code>存储了实际的元素，然后通过向前和向后的链接使容器中的多个元素形成一个链表。结点定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;<span class="comment">// 实际存储的数据</span></span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">// 前一个结点引用</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">// 后一个结点引用</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedList没用数组结构，它的根据下标获取元素是如何实现的"><a href="#LinkedList没用数组结构，它的根据下标获取元素是如何实现的" class="headerlink" title="LinkedList没用数组结构，它的根据下标获取元素是如何实现的"></a>LinkedList没用数组结构，它的根据下标获取元素是如何实现的</h2><p>LinkedList是<code>List</code>接口的一个实现，List接口中规定了按照元素在列表中的位置获取元素的方法<code>E get(int index)</code>,对于使用数组实现的<code>ArrayList</code>来说这是很容易的，因为元素在列表中的位置就是它在数组中的下标。</p><p>对于使用链表结构的<code>LinkedList</code>来说，每个结点并没有像数组那样存储元素在列表中的位置，所以按位置查找元素时只能按一定的顺序遍历链表直到到达指定位置然后才能取出元素，其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);<span class="comment">//index &gt;= 0 &amp;&amp; index &lt; size;</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>node(int index)实现了按位置查找链表结点，而且经过了一次二分优化，从而把最坏查找时间减少一半：</p><ul><li>当给定位置位于链表前半部分时从前往后遍历链表</li><li>当给定位置位于链表后半部分时从后往前遍历链表</li></ul><h2 id="正确地遍历删除列表中的元素"><a href="#正确地遍历删除列表中的元素" class="headerlink" title="正确地遍历删除列表中的元素"></a>正确地遍历删除列表中的元素</h2><p>List集合的相应实现一般都会有<code>fail-fast</code>机制，以防止遍历列表时修改列表，List接口的相应实现通过记录列表的修改次数<code>modCount</code>来实现，添加，删除元素元素时修改次数递增。</p><p>expectedModCount则是表示迭代器对集合进行修改的次数。<br>设置expectedModCount的目的就是要保证在使用迭代器期间，LinkedList对象的修改只能通过迭代器且只能这一个迭代器进行。</p><p>在迭代器中修改集合时，同时修改<code>modCount</code>和<code>expectedModCount</code>的值，并且在修改之前检查二者是否一致，如果不一致这说明集合已经在其他地方被修改过，此时将抛出<code>ConcurrentModificationException</code>异常。所以在使用List时应该注意：</p><ul><li>确保所有元素都被添加完毕时才使用其迭代器</li><li>需要遍历修改集合时确保使用迭代器操作集合</li></ul><p>针对第二点有个有趣的事情，假如我想删除集合中的所有元素，可不可以用迭代器进行呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIteDel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"><span class="comment">//            Integer item = iterator.next();</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码运行将抛出<code>java.lang.IllegalStateException</code>异常，而放开代码中的注释则可以正常运行，原因是<code>move()</code>方法中会检查当前迭代返回值<code>lastReturned</code>是否为null，是则抛出此异常，而<code>lastReturned</code>只在<code>next()</code>和<code>previous()</code>方法中赋值，所以在删除前应该调用一下它们，否则会认为当前迭代没有值返回，既然没有值的时候去删除就应该是不合法的状态。</p><p><strong>清空List中的元素还是老老实实地调用现成的<code>clear()</code>方法吧</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/notes/LinkedList.png&quot; alt=&quot;LinkedList继承结构&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://balderdasher.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://balderdasher.github.io/tags/java/"/>
    
      <category term="集合" scheme="https://balderdasher.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList那点事</title>
    <link href="https://balderdasher.github.io/2017/12/28/things-about-arraylist/"/>
    <id>https://balderdasher.github.io/2017/12/28/things-about-arraylist/</id>
    <published>2017-12-28T10:16:07.000Z</published>
    <updated>2021-09-29T06:04:29.564Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/notes/ArrayList.png" alt="ArrayList继承结构"></p><a id="more"></a><h2 id="简单概述一下ArrayList这种数据结构"><a href="#简单概述一下ArrayList这种数据结构" class="headerlink" title="简单概述一下ArrayList这种数据结构"></a>简单概述一下ArrayList这种数据结构</h2><blockquote><p><code>ArrayList</code>是Java集合框架中<code>List</code>分支的一个具体实现类，属于元素<strong>有序</strong>、<strong>可重复</strong>、<strong>可为null</strong>的序列。它有用List接口的通用功能：</p><ul><li>可以精确控制元素插入列表中的位置</li><li>可以通过元素在列表中的下标访问元素</li><li>可以在列表中查找元素</li></ul></blockquote><h2 id="如何理解ArrayList的有序性？"><a href="#如何理解ArrayList的有序性？" class="headerlink" title="如何理解ArrayList的有序性？"></a>如何理解ArrayList的有序性？</h2><p>ArrayList的有序性基于其底层的数据结构<em>数组</em>，数组是内存中一块连续的空间，list中的元素就存储在这个数组之上，数组本身是连续的，而且ArrayList插入或获取元素时可以指定元素所在的位置，这个位置映射到数组的下标，因此我们可以控制元素在列表中的顺序，所以说ArrayList是有序的</p><p>至于列表中元素的可重复性，是因为数组的数据结构决定了其中的元素之间是没有相互依赖关系的，所以不同位置的元素可以重复。</p><h2 id="ArrayList的初始容量是多少？"><a href="#ArrayList的初始容量是多少？" class="headerlink" title="ArrayList的初始容量是多少？"></a>ArrayList的初始容量是多少？</h2><p>假如有定义<code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</code></p><blockquote><p>问：此时list的容量是多少？</p></blockquote><p>正确的解答应该是<code>0</code>而不是类中定义的<code>DEFAULT_CAPACITY = 10</code>，请看如下源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == EMPTY_ELEMENTDATA will be expanded to</span></span><br><span class="line"><span class="comment"> * DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，通过无参构造器初始化一个<code>ArrayList</code>时，实际存储元素的<code>elementData</code>是一个空数组，并没有分配空间，所以此时list容量为0.</p><p>其实<code>elementData</code>的注释已经说明：<strong>刚通过无参构造器初始化时的<code>ArrayList</code>在第一个元素被添加时才扩充其容量为默认的10</strong>。</p><p>这种设计无疑是合理的，否则当有大量的ArrayList被初始化而没有被使用时，将会浪费一些没有被实际利用的内存空间。这种设计将内存的分配延迟到了第一次向列表中添加元素的时机。</p><p>由此可见，无参构造器<code>ArrayList()</code>上的注释是不准确的。</p><h2 id="ArrayList的扩容机制是什么样的？"><a href="#ArrayList的扩容机制是什么样的？" class="headerlink" title="ArrayList的扩容机制是什么样的？"></a>ArrayList的扩容机制是什么样的？</h2><p>当ArrayList达到容量上限，也就是底层的数组没有多余的空间存储新元素时，ArrayList将会扩容，扩容操作一般发生在向列表中添加元素时，扩充的容量为原来的一半，即扩充后的容量为原来容量的<code>1.5</code>倍。相当于重新分配了一个较长的数组，然后把之前数组上的元素都复制到新的数组中去。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/notes/ArrayList.png&quot; alt=&quot;ArrayList继承结构&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://balderdasher.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://balderdasher.github.io/tags/java/"/>
    
      <category term="集合" scheme="https://balderdasher.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>java引用传递这点事</title>
    <link href="https://balderdasher.github.io/2017/12/27/pass-value-in-java/"/>
    <id>https://balderdasher.github.io/2017/12/27/pass-value-in-java/</id>
    <published>2017-12-27T11:09:23.000Z</published>
    <updated>2021-09-29T06:04:29.567Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/notes/pass-value-in-java-example.png" alt="pass-value-in-java"><br><a id="more"></a><br>今天在看<code>java.io</code>包时看到一个类<code>DeleteOnExitHook</code>，这个类中有如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runHooks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedHashSet&lt;String&gt; theFiles;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (DeleteOnExitHook.class) &#123;</span><br><span class="line">        theFiles = files;</span><br><span class="line">        files = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; toBeDeleted = <span class="keyword">new</span> ArrayList&lt;&gt;(theFiles);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse the list to maintain previous jdk deletion order.</span></span><br><span class="line">    <span class="comment">// Last in first deleted.</span></span><br><span class="line">    Collections.reverse(toBeDeleted);</span><br><span class="line">    <span class="keyword">for</span> (String filename : toBeDeleted) &#123;</span><br><span class="line">        (<span class="keyword">new</span> File(filename)).delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的作用是注册一个<code>shutdown hook</code>(关闭钩子)，jvm退出时会自动删除指定的文件列表。以上方法在类的静态块代码中注册的关闭钩子中的线程类执行。要删除的文件列表则可以通过<code>File</code>类中的<code>deleteOnExit()</code>方法添加，此方法会调用<code>DeleteOnExitHook</code>类中的静态方法<code>add()</code>将文件注册到待删除文件列表。</p><p>以上不是重点，重点是以上代码中同步块中的代码，乍一看会产生一种错觉：<code>theFiles</code>为<code>null</code>了，想想也是啊，A=B,B=0,A岂不就是等于0了？</p><p>其实不然，至少在java中不是这样的。以下的程序将会验证<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; strs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    strs.addAll(Arrays.asList(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>));</span><br><span class="line">    List&lt;String&gt; temp = strs;</span><br><span class="line">    strs = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码的输出结果会是什么呢？我在群聊中贴出了以上代码，有不少同学的答案是<code>null</code>。</p><p>实际上的输出是：</p><blockquote><p>[1, 2, 3]</p></blockquote><p>看来还真的是看起来越简单的东西越容易犯迷糊也越容易忘记，之所以会是以上输出归根结底就是一句话：<strong>Java只有值传递</strong>。<br>来一张图看得更清楚些：<br><img src="/uploads/notes/pass-value-in-java.png" alt="pass-value-in-java"></p><p>从图中可以看出，<code>temp=strs</code>看起来是把<code>strs</code>的引用传递给了<code>temp</code>，实际上传递的是在堆中对象的地址，strs的引用传递给temp，意味着temp引用指向的地址与strs的一样，当<code>strs=null</code>时，意味着strs不指向任何堆中的对象了。</p><p><strong>在java中，<code>ref=null</code>意味着引用ref不指向任何对象，而不是把ref指向的对象设置为null</strong>。如果ref=null就能把它所指对象设为null的话，gc就没有存在的意义了。</p><p>对于java中的引用传递，一个更容易理解的例子就是两个贼与一个储物柜的情景，贼<code>A</code>(引用a)抢了珠宝店后把珠宝（对象）藏在一个号码为<code>110</code>(对象的实际地址)的储物柜(堆)里，他持有这个储物柜的钥匙<code>key1</code>，同时贼<code>B</code>来接头了，贼<code>A</code>配了一把钥匙<code>key2</code>给贼<code>B</code>，这时候老大来了，他说小A啊，你那把钥匙还留着有点不地道吧，贼A只能把<code>key1</code>销毁了(设为null)，这时候相当于贼A与珠宝失去了联系，而贼B可以拿着钥匙打开储物柜。见图：<br><img src="/uploads/notes/pass-value-in-java-example.png" alt="pass-value-in-java"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/notes/pass-value-in-java-example.png&quot; alt=&quot;pass-value-in-java&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://balderdasher.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://balderdasher.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal实现原理</title>
    <link href="https://balderdasher.github.io/2017/12/26/how-thread-local-works/"/>
    <id>https://balderdasher.github.io/2017/12/26/how-thread-local-works/</id>
    <published>2017-12-26T07:48:56.000Z</published>
    <updated>2021-09-29T06:04:29.567Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>ThreadLocal</code>类提供了线程局部(thread-local)变量。通过<code>get()</code>或<code>set()</code>访问某个变量的每个线程都有自己的局部变量，它独立于变量的初始化副本，<code>ThreadLocal</code>实例通常是类中的<code>private static</code>字段，用于将某一状态和线程关联。</p></blockquote><a id="more"></a><h2 id="ThreadLocal是如何和线程关联起来的"><a href="#ThreadLocal是如何和线程关联起来的" class="headerlink" title="ThreadLocal是如何和线程关联起来的"></a>ThreadLocal是如何和线程关联起来的</h2><p>刚开始使用<code>ThreadLocal</code>的时候总会感觉很神奇，通过<code>set()</code>设置一下想用的变量，通过<code>get()</code>就可以取出来了，而且不同的线程之间相互不影响，线程局部变量，果真是名副其实。不过到底是怎么实现的呢，线程是线程，ThreadLocal是ThreadLocal，我们只使用了<code>ThreadLocal</code>就实现了不同的线程持有不同的变量，这些变量是如何与线程关联的呢，因为我们并没有去手动去关联它们。</p><p>我们通过查看<code>Thread</code>和<code>ThreadLocal</code>的源码，看看它们之间到底是通过什么建立起联系的。发现在<code>Thread</code>类中有如下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>由注释可知，它们之间的联系就是通过以上这个字段建立联系的。<code>threadLocals</code>字段负责保存与当前线程相关联的局部变量，它是<code>ThreadLocal</code>中的一个静态内部类<code>ThreadLocalMap</code>，ThreadLocalMap是支撑ThreadLocal实现的数据结构，类似于常用的<code>HashMap</code>，我们使用<code>ThreadLocal</code>其实就是通过设置这个map去维护线程局部变量的。此map中存储的键值对定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由定义可知，这个键值对的键是<code>ThreadLocal</code>对象，值则是我们想要设置的具体变量值。</p><p>所以，线程与<code>ThreadLocal</code>的关系通俗来说就是：ThreadLocal就是线程局部变量，一个线程可以设置多个局部变量，也就是多个<code>ThreadLocal</code>，线程通过一个Map结构去维护我们设置的多个<code>ThreadLocal</code>，在这个map结构中，我们通过把先前设置的<code>ThreadLocal</code>对象用作键就可以取到具体的线程局部变量了。</p><h2 id="ThreadLocal是如何维护线程局部变量的"><a href="#ThreadLocal是如何维护线程局部变量的" class="headerlink" title="ThreadLocal是如何维护线程局部变量的"></a>ThreadLocal是如何维护线程局部变量的</h2><p>通过之前的分析知道线程局部变量是由<code>ThreadLocal</code>类维护的，此类是如何维护当前线程的局部变量的呢，主要通过两个方法分析：<code>set()</code>、<code>get()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; userName = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; userLevel = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Processor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Processor</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            userName.set(<span class="string">"user_"</span> + id);</span><br><span class="line">            userLevel.set(<span class="keyword">new</span> Random().nextInt(<span class="number">6</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" local vars:&#123;"</span> + <span class="string">"username:"</span> + userName.get() + <span class="string">",userlevel:"</span> + userLevel.get() + <span class="string">"&#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String id = i + <span class="number">1</span> + <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Processor(id), <span class="string">"thread_"</span> + id).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>thread_1 local vars:{username:user_1,userlevel:0}<br>thread_2 local vars:{username:user_2,userlevel:3}<br>thread_3 local vars:{username:user_3,userlevel:4}<br>thread_4 local vars:{username:user_4,userlevel:5}<br>thread_5 local vars:{username:user_5,userlevel:3}</p></blockquote><p>以上的代码演示了<code>ThreadLocal</code>的基本使用，通常我们最多的操作就是对变量的设置和获取，对应<code>set()</code>和<code>get()</code>方法，前者在设置变量时使用，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简短的代码，联系上面<code>ThreadLocal</code>的使用demo，其逻辑为：当我们在某处设置ThreadLocal时，获取当前所在的线程，并从中取出当前线程的局部变量map，map存在则设置局部变量为当前值，否则创建新的map并设置变量值然后把此map设置为当前线程的局部变量表<code>threadLocals</code>(ThreadLocal和Thread建立联系)。</p><p>在此之后的<code>get()</code>操作就容易理解了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也是获取当前线程，然后从中取出局部变量表<code>threadLocals</code>，若不为空(设置过变量)则从变量表中通过用当前的<code>ThreadLocal</code>对象作为键取出对应的变量值。如果之前没有设置过局部变量，则返回初始化值（默认<code>null</code>）。这个初始化值是由<code>initialValue()</code>方法决定的，在初始化<code>ThreadLocal</code>时可以重写此方法以设置默认值。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;类提供了线程局部(thread-local)变量。通过&lt;code&gt;get()&lt;/code&gt;或&lt;code&gt;set()&lt;/code&gt;访问某个变量的每个线程都有自己的局部变量，它独立于变量的初始化副本，&lt;code&gt;ThreadLocal&lt;/code&gt;实例通常是类中的&lt;code&gt;private static&lt;/code&gt;字段，用于将某一状态和线程关联。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="https://balderdasher.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://balderdasher.github.io/tags/java/"/>
    
      <category term="threadlocal" scheme="https://balderdasher.github.io/tags/threadlocal/"/>
    
  </entry>
  
  <entry>
    <title>解决idea类报红找不到的问题</title>
    <link href="https://balderdasher.github.io/2017/10/11/fix-idea-show-red-on-codes/"/>
    <id>https://balderdasher.github.io/2017/10/11/fix-idea-show-red-on-codes/</id>
    <published>2017-10-11T04:13:06.000Z</published>
    <updated>2021-09-29T06:04:29.573Z</updated>
    
    <content type="html"><![CDATA[<p>国庆假期回来之后打开电脑，ide打开之后发现之前一切正常的程序代码出问题了：具体表现为某个或某几个类引用报红，提示：<code>Cannot resolve symbol &#39;SomeClass&#39;</code>，但是在出现问题的类中执行<code>main()</code>方法确实没有问题的，就像下图所展示的一样：</p><p><img src="https://i.imgur.com/nifLGi5.png" alt><br><a id="more"></a><br>刚开始我以为是ide的bug，网上搜了一下，原来是缓存的问题：解决办法如下</p><p><img src="https://i.imgur.com/PMHXqrj.png" alt></p><p><img src="https://i.imgur.com/aL8zqMT.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国庆假期回来之后打开电脑，ide打开之后发现之前一切正常的程序代码出问题了：具体表现为某个或某几个类引用报红，提示：&lt;code&gt;Cannot resolve symbol &amp;#39;SomeClass&amp;#39;&lt;/code&gt;，但是在出现问题的类中执行&lt;code&gt;main()&lt;/code&gt;方法确实没有问题的，就像下图所展示的一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/nifLGi5.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="奇门遁甲" scheme="https://balderdasher.github.io/categories/%E5%A5%87%E9%97%A8%E9%81%81%E7%94%B2/"/>
    
    
      <category term="idea" scheme="https://balderdasher.github.io/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》第21章-并发</title>
    <link href="https://balderdasher.github.io/2017/06/05/thinking-in-java-concurrent/"/>
    <id>https://balderdasher.github.io/2017/06/05/thinking-in-java-concurrent/</id>
    <published>2017-06-05T03:11:05.000Z</published>
    <updated>2021-09-29T06:04:29.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于并发"><a href="#关于并发" class="headerlink" title="关于并发"></a>关于并发</h2><p><strong>为什么需要并发</strong></p><p>编程问题中的很多部分都可以通过使用顺序编程来解决，顺序编程，就是程序中的所有事物在任意时刻都只能执行一个步骤。然而对于某些问题，如果能够并行地执行程序中的多个部分，会非常高效而且方便，这些部分要么看起来在并发地执行，要么在多处理器的环境下可以同时执行。并行编程可以是程序执行速度得到极大提高。</p><a id="more"></a><p><strong>什么是并发</strong></p><p>并发简单地讲，就是并行地执行程序中的多个部分。</p><h2 id="21-1-基本的线程机制"><a href="#21-1-基本的线程机制" class="headerlink" title="21.1 基本的线程机制"></a>21.1 基本的线程机制</h2><blockquote><p>并发编程使我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务中的每一个都将由<strong>执行线程</strong>来驱动。一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务，但是程序使得每个任务都好像有自己的CPU一样，其底层机制是切分CPU时间，我们通常不需要考虑它。<br>线程模型为编程带来了便利，它简化了在单一程序中同事交织在一起的多个操作的处理。在使用线程时，CPU将轮流给每个任务非配其占用时间。每个任务都觉得自己在一直占用CPU，但事实上CPU时间是划分成片段分配给了所有的任务（除非确实运行在多处理器机器上），线程的一大好处就是可以使我们从这个层次抽身而出，代码不必知道它是运行在具有一个还是多个CPU的机器上，所以，使用线程机制是一种建立透明的、可扩展的程序的方法。为什么呢，因为如果程序运行缓慢的话，多加几个CPU就可以加快程序的运行速度。</p></blockquote><h3 id="21-1-1-定义任务"><a href="#21-1-1-定义任务" class="headerlink" title="21.1.1 定义任务"></a>21.1.1 定义任务</h3><p>线程可以驱动任务，<code>Runnable</code>接口提供了一种描述任务的方式，想要定义任务，只需实现<code>Runnable</code>接口并编写其中的<code>run()</code>方法即可，使得该任务可以执行你的命令，以下是一个显示发射倒计时的任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Runnable定义任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-27 14:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> countDown = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> taskCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = taskCount++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">(<span class="keyword">int</span> countDown)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDown = countDown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">status</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span> + id + <span class="string">"("</span> + (countDown &gt; <span class="number">0</span> ? countDown : <span class="string">"LiftOff!"</span>) + <span class="string">"), "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (countDown-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(status());</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LiftOff launch = <span class="keyword">new</span> LiftOff();</span><br><span class="line">        launch.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(LiftOff!),</span><br></pre></td></tr></table></figure></p><p>任务的<code>run()</code>方法通常总会有某种形式的循环，使得任务一直运行下去直到不再需要，所以要设定跳出循环的条件（有种选择是直接从run（）返回）。通常<code>run()</code>被写成无限循环的形式，意味着除非某个条件使得<code>run()</code>停止，否则它将永远运行下去。</p><p>在<code>run</code>中对静态方法<code>Thread.yield()</code>的调用时对<strong>线程调度器</strong>（Java线程机制的一部分，可以将CPU从一个线程转移给另一个线程）的一种建议，它意思是说：“我已经执行完生命周期中最重要的部分了，此刻正式切换给其他任务执行一段时间的大好时机。”</p><p>当实现<code>Runnable</code>接口定义一个任务时，必须具有<code>run()</code>方法，但这个方法并没有什么特殊之处——它不会产生任何内在的线程能力，要实现线程的行为，必须要显式地将任务附着到线程上。</p><h3 id="21-1-2-Thread类"><a href="#21-1-2-Thread类" class="headerlink" title="21.1.2 Thread类"></a>21.1.2 Thread类</h3><p>正如上面所说，将<code>Runnable</code>对象转变为工作任务的传统方式就是把它提交给一个<code>Thread</code>构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">"Waiting for LiftOff"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(LiftOff!),</span><br></pre></td></tr></table></figure></p><p>通过程序得知，<code>Thread</code>构造器只需要一个<code>Runnable</code>对象。调用<code>Thread</code>对象的<code>start()</code>方法为该线程执行必须的初始化操作，然后调用<code>Runnable</code>的run()方法（从输出中可以看出），以便在这个新线程中启动该任务。</p><p>观察程序我们会觉得<code>start()</code>应该是产生了一个对长期运行方法的调用，<code>Waiting for LiftOff</code>这一句应该输出在最后，但输出告诉我们并不是这样的，输出可以看出，start()迅速返回了，因为<code>Waiting for LiftOff</code>出现在了第一句。实际上，start（）产生的是对<code>LiftOff.run()</code>的方法调用，并且这个方法还没有完成，因为<code>LiftOff.run()</code>是在新线程中执行的，所以我们可以执行位于<code>main()</code>线程中的其他操作（不局限与main（），任何线程都可以启动另一个线程），因此，程序会同时运行两个方法，<code>main()</code>和<code>LiftOff.run()</code>是程序中与其他线程“同时”执行的代码。</p><p>当我们添加更多地线程去驱动更多的任务时，任务之间的彼此呼应会看得更清楚一些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更多的线程驱动更多的任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-27 15:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreBasicThreads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Waiting for LiftOff"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Waiting for LiftOff</span><br><span class="line"> #0(9), #3(9), #1(9), #2(9), #4(9), #0(8), #3(8), #1(8), #2(8), #4(8), #0(7),</span><br><span class="line"> #3(7), #2(7),#4(7), #1(7), #0(6), #3(6), #4(6), #1(6), #2(6), #0(5), #3(5), </span><br><span class="line"> #4(5), #1(5),#2(5), #0(4),#3(4), #4(4), #1(4), #2(4), #0(3), #3(3), #4(3), </span><br><span class="line"> #2(3), #1(3), #0(2), #3(2),#4(2), #2(2),#1(2), #0(1), #3(1), #4(1), #2(1), #1(1), </span><br><span class="line"> #0(LiftOff!), #3(LiftOff!), #2(LiftOff!), #4(LiftOff!), #1(LiftOff!),</span><br></pre></td></tr></table></figure></p><p>以上程序的输出可能会每次都不一样，另外也会随着JDK版本的不同而表现出差异，较早的JDK不会频繁对时间切片，因此线程1可能会先执行完然后线程2再执行，较晚的JDK看起来会产生更好的时间切片行为。</p><h3 id="21-1-3-使用Executor"><a href="#21-1-3-使用Executor" class="headerlink" title="21.1.3 使用Executor"></a>21.1.3 使用Executor</h3><p>Executor是<code>java.util.concurrent</code>包中为我们管理<code>Thread</code>对象的<strong>执行器</strong>，Executor在客户端和任务执行之间提供了一个间接层；与客户端直接执行任务不同，这个中介对象将执行任务。Executor允许我们管理异步任务的执行而无须显式地管理线程的生命周期。Executor是Java SE5/6中启动任务的优选方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子使用Executor实现了发射倒计时，<code>ExecutorService</code>是具有服务生命周期的Executor，例如关闭等，它知道如何构建恰当的上下文来执行Runnable对象，<code>CachedThreadPool</code>将为每个任务都创建一个线程，<code>ExecutorService</code>对象是使用静态的Executor方法创建的，这个方法可以确定Executor的类型。</p><p>在最后对<code>shutdown()</code>方法的调用目的是为了防止新任务被提交给这个Executor，当前线程将继续运行在<code>shutdown()</code>被调用之前所提交的所有任务，这个程序将在Executor中的所有任务完成之后尽快退出。</p><p>上述例子中我们明确启动了5个线程来执行不同的任务，这时候我们可以将CachedThreadPool替换为不同类型的Executor，正如上例所示，当我们需要使用有限的线程集来执行所提交任务的时候，通常使用<code>FixedThreadPool</code></p><p>使用FixedThreadPool，就可以一次性地预先执行代价高昂的线程分配，所以也就可以限制线程的数量了，这样可以节省时间，因为不用为每个任务都固定地付出创建线程的开销。在事件驱动的系统中，需要线程的事件处理器，通过直接从池中获取线程，也可以得到相应的服务，而且我们不会滥用可获得的资源，因为FixedThreadPool使用的Thread对象的数量是有界的。</p><p>注意，在任何线程池中，现有线程在有可能的情况下，都会被自动复用。</p><p><code>CachedThreadPool</code>在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选，只有当这种方式会引发问题时，才需要考虑切换到FixedThreadPool。</p><p>SingleThreadExecutor就好比线程数量为1的FixedThreadPool，这对于希望在另一个线程中连续运行的任何事物（长期存活的任务）来说，都是很有用的。</p><h3 id="21-1-4-从任务中产生返回值"><a href="#21-1-4-从任务中产生返回值" class="headerlink" title="21.1.4 从任务中产生返回值"></a>21.1.4 从任务中产生返回值</h3><p>Runnable是执行工作的独立任务，但是它不产生任何返回值，如果希望任务完成时能够返回一个值，应该实现<code>Callable</code>接口而不是<code>Runnable</code>接口。<code>Callable</code>是一种具有类型参数的泛型，它的类型参数表示的是从方法<code>call()</code>(而不是run())中返回的值，并且必须使用<code>ExecutorService.submit()</code>方法调用它，下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要从任务返回一个值时使用Callable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-28 14:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"result of TaskWithResult "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fs:results)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">                <span class="comment">//java7以上特性，可以对一个或多个异常做相同的处理</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result of TaskWithResult 0</span><br><span class="line">result of TaskWithResult 1</span><br><span class="line">result of TaskWithResult 2</span><br><span class="line">result of TaskWithResult 3</span><br><span class="line">result of TaskWithResult 4</span><br><span class="line">result of TaskWithResult 5</span><br><span class="line">result of TaskWithResult 6</span><br><span class="line">result of TaskWithResult 7</span><br><span class="line">result of TaskWithResult 8</span><br><span class="line">result of TaskWithResult 9</span><br></pre></td></tr></table></figure></p><p>如上所示，<code>submit()</code>方法会产生<code>Future</code>对象，它用<code>Callable</code>返回结果的特定类型进行了参数化。可以用<code>isDone()</code>方法来查询<code>Future</code>是否已经完成。当任务完成时，可以调用<code>get()</code>方法来获取结果，事实上也可以不用调用<code>isDone()</code>检查就直接调用<code>get()</code>，这时候get()将阻塞直到结果准备就绪。</p><h3 id="21-1-5-休眠"><a href="#21-1-5-休眠" class="headerlink" title="21.1.5 休眠"></a>21.1.5 休眠</h3><p>影响任务行为的一种简单方法是调用<code>sleep()</code>，这将使任务终止执行给定的时间。在<code>LiftOff</code>中把<code>yield()</code>换成<code>sleep()</code>会怎样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用sleep</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-28 14:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepingTask</span> <span class="keyword">extends</span> <span class="title">LiftOff</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (countDown-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(status());</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> SleepingTask());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#0(9), #2(9), #1(9), #3(9), #4(9), #4(8), #3(8), #1(8), #2(8), #0(8), #2(7), #1(7), #3(7),</span><br><span class="line">#4(7), #0(7), #4(6), #3(6), #0(6), #2(6), #1(6), #1(5), #2(5), #0(5), #3(5), #4(5), #1(4),</span><br><span class="line">#0(4), #2(4), #3(4), #4(4), #4(3), #3(3), #0(3), #2(3), #1(3), #1(2), #3(2), #4(2), #0(2),</span><br><span class="line">#2(2), #2(1), #0(1), #4(1), #3(1), #1(1), #3(LiftOff!), #4(LiftOff!), #0(LiftOff!), #2(LiftOff!), #1(LiftOff!),</span><br></pre></td></tr></table></figure></p><h3 id="21-1-6-优先级"><a href="#21-1-6-优先级" class="headerlink" title="21.1.6 优先级"></a>21.1.6 优先级</h3><p>线程的<strong>优先级</strong>将该线程的重要性传递给了调度器。调度器将倾向于让优先级最高的线程先执行，然而并不意味着优先级较低的线程得不到执行（优先级不会导致死锁），仅仅只是执行顺序较低而已。</p><p><strong>大多数情况下，所有线程都应该以默认的优先级运行，试图操纵线程的优先级通常会带来问题。</strong></p><p>下面是演示优先级的示例，可以用<code>getPriority()</code>来读取现有线程的优先级，并且在任何时刻都可以通过<code>setPriority()</code>来修改它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程优先级演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-28 15:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePriority</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimplePriority</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread() + <span class="string">": "</span> + countDown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().setPriority(priority);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                d += (Math.PI + Math.E) / (<span class="keyword">double</span>) i;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (--countDown == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> SimplePriority(Thread.MIN_PRIORITY));</span><br><span class="line">        &#125;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> SimplePriority(Thread.MAX_PRIORITY));</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Thread[pool-1-thread-6,10,main]: 5</span><br><span class="line">Thread[pool-1-thread-6,10,main]: 4</span><br><span class="line">Thread[pool-1-thread-6,10,main]: 3</span><br><span class="line">Thread[pool-1-thread-6,10,main]: 2</span><br><span class="line">Thread[pool-1-thread-6,10,main]: 1</span><br><span class="line">Thread[pool-1-thread-1,1,main]: 5</span><br><span class="line">Thread[pool-1-thread-1,1,main]: 4</span><br><span class="line">Thread[pool-1-thread-1,1,main]: 3</span><br><span class="line">Thread[pool-1-thread-1,1,main]: 2</span><br><span class="line">Thread[pool-1-thread-1,1,main]: 1</span><br><span class="line">Thread[pool-1-thread-2,1,main]: 5</span><br><span class="line">Thread[pool-1-thread-2,1,main]: 4</span><br><span class="line">Thread[pool-1-thread-2,1,main]: 3</span><br><span class="line">Thread[pool-1-thread-2,1,main]: 2</span><br><span class="line">Thread[pool-1-thread-2,1,main]: 1</span><br><span class="line">Thread[pool-1-thread-3,1,main]: 5</span><br><span class="line">Thread[pool-1-thread-3,1,main]: 4</span><br><span class="line">Thread[pool-1-thread-3,1,main]: 3</span><br><span class="line">Thread[pool-1-thread-3,1,main]: 2</span><br><span class="line">Thread[pool-1-thread-3,1,main]: 1</span><br><span class="line">Thread[pool-1-thread-4,1,main]: 5</span><br><span class="line">Thread[pool-1-thread-4,1,main]: 4</span><br><span class="line">Thread[pool-1-thread-4,1,main]: 3</span><br><span class="line">Thread[pool-1-thread-4,1,main]: 2</span><br><span class="line">Thread[pool-1-thread-4,1,main]: 1</span><br><span class="line">Thread[pool-1-thread-5,1,main]: 5</span><br><span class="line">Thread[pool-1-thread-5,1,main]: 4</span><br><span class="line">Thread[pool-1-thread-5,1,main]: 3</span><br><span class="line">Thread[pool-1-thread-5,1,main]: 2</span><br><span class="line">Thread[pool-1-thread-5,1,main]: 1</span><br></pre></td></tr></table></figure></p><p>以上程序中，在<code>run()</code>里执行了10000次开销很大的浮点运算，如果没有加入这些运算的话，就看不到设置优先级的效果，有了这些运算，可以看到最高优先级的线程被线程调度器优先选择执行。</p><p>尽管JDK有10个优先级，但它与多数操作系统都不能良好地映射，比如Windows有7个优先级是不固定的，所以这种映射关系也是不确定的，唯一可移植的方法是当调整优先级的时候，只使用<code>MAX_PRIORITY</code>、<code>NORM_PRIORITY</code>和<code>MIN_PRIORITY</code>三种级别。</p><h3 id="21-1-7-让步"><a href="#21-1-7-让步" class="headerlink" title="21.1.7 让步"></a>21.1.7 让步</h3><p>如果我们已经确认已经完成了<code>run()</code>中一次循环迭代过程所需的工作，就可以给线程调度机制一个提示：你的工作已经做得差不多了，可以让别的线程使用CPU了。这个提示通过调用<code>yield()</code>方法来做出，不过这只是一个提示，没有任何机制能保证它将会被采纳。当调用<code>yield()</code>时，也意味着我们在建议具有<strong>相同优先级</strong>的其他线程可以运行。</p><p>一般情况下，对于任何重要的控制或在调整应用时，都不能依赖于<code>yield()</code>，实际上<code>yield()</code>经常被误用。</p><h3 id="21-1-8-后台线程"><a href="#21-1-8-后台线程" class="headerlink" title="21.1.8 后台线程"></a>21.1.8 后台线程</h3><p>所谓后台（daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止，比如，执行<code>main()</code>的就是一个非后台线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后台线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-28 17:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDaemons</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">": "</span> + <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"sleep() interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread daemon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SimpleDaemons());</span><br><span class="line">            daemon.setDaemon(<span class="keyword">true</span>);<span class="comment">//必须在start()之前设置</span></span><br><span class="line">            daemon.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"All daemons started"</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">175</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">All daemons started</span><br><span class="line">Thread[Thread-7,5,main]: com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter21.SimpleDaemons@5826d8e6</span><br><span class="line">Thread[Thread-6,5,main]: com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter21.SimpleDaemons@5e6a1140</span><br><span class="line">Thread[Thread-8,5,main]: com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter21.SimpleDaemons@1ad60225</span><br><span class="line">Thread[Thread-1,5,main]: com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter21.SimpleDaemons@61ae0436</span><br><span class="line">Thread[Thread-9,5,main]: com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter21.SimpleDaemons@1ad60225</span><br><span class="line">Thread[Thread-2,5,main]: com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter21.SimpleDaemons@6796a753</span><br><span class="line">Thread[Thread-0,5,main]: com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter21.SimpleDaemons@592b12d</span><br><span class="line">Thread[Thread-4,5,main]: com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter21.SimpleDaemons@43be87a0</span><br><span class="line">Thread[Thread-5,5,main]: com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter21.SimpleDaemons@53c36f46</span><br><span class="line">Thread[Thread-3,5,main]: com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter21.SimpleDaemons@11ba3c1f</span><br></pre></td></tr></table></figure></p><p>必须在线程启动之前调用<code>setDaemon()</code>方法，才能把此线程设置为后台线程。</p><p>在以上程序中，如果注释掉<code>main()</code>方法里的最后一句代码或者main()线程的睡眠时间改为100以下或者大于100但是很接近100时会怎样呢？我们会看不到线程启动后的输出结果，因为一旦<code>main()</code>一旦完成它的工作，就没有什么能阻止程序终止了，因为除了后台线程以外，已经没有线程在运行了。</p><h3 id="21-1-9-加入一个线程"><a href="#21-1-9-加入一个线程" class="headerlink" title="21.1.9 加入一个线程"></a>21.1.9 加入一个线程</h3><p>一个线程可以在另一个线程上调用<code>join()</code>方法，效果就是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程<code>t</code>上调用<code>t.join</code>，此线程将被挂起，直到目标线程<code>t</code>结束才恢复(即t.isAlive()返回false)。</p><p>也可以在调用<code>join()</code>时带上一个超时参数，这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回。</p><p>对<code>join()</code>方法的调用可以被中断，做法是在调用线程上调用<code>interrupt()</code>方法，这时候需要处理异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程加入（join）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-28 17:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hide</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> duration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hide</span><span class="params">(String name, <span class="keyword">int</span> sleepTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        duration = sleepTime;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(duration);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">" was interrupted "</span> + <span class="string">"isInterrupted(): "</span> + isInterrupted());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName() + <span class="string">" has hided"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seek</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hide child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Seek</span><span class="params">(String name, Hide child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            child.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(child.getName() + <span class="string">" has hided and "</span> + getName() + <span class="string">" can go get him"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HideAndSeek</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hide</span><br><span class="line">                tom = <span class="keyword">new</span> Hide(<span class="string">"tom"</span>, <span class="number">1500</span>),</span><br><span class="line">                jack = <span class="keyword">new</span> Hide(<span class="string">"jack"</span>, <span class="number">1500</span>);</span><br><span class="line">        Seek</span><br><span class="line">                dad = <span class="keyword">new</span> Seek(<span class="string">"dad"</span>, tom),</span><br><span class="line">                mom = <span class="keyword">new</span> Seek(<span class="string">"mom"</span>, jack);</span><br><span class="line"><span class="comment">//        jack.interrupt();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tom has hided</span><br><span class="line">tom has hided and dad can go get him</span><br><span class="line">jack has hided</span><br><span class="line">jack has hided and mom can go get him</span><br></pre></td></tr></table></figure></p><p>以上是一个演示捉迷藏游戏的程序，父母和两个孩子捉迷藏，孩子藏起来让父母找，孩子藏的时间是构造函数的参数决定的，孩子在规定的时间内藏好了，父母才能开始寻找，也就是说父母只能等待孩子藏好之后才能开始找，所以在<code>Seek</code>线程中的加入了<code>Hide</code>线程，hide好了，才能seek。</p><p>上述代码中注释掉的最后一句模拟了中断，被中断的线程调用<code>isInterrupted()</code>方法返回的将是ture，因为调用<code>.interrupt()</code>方法的时候会为线程的此标志设置值，然而，如果放开注释，将会看到此值是false，这是因为在异常被捕获的时候这个标志总是为false。</p><h2 id="21-2-共享受限资源"><a href="#21-2-共享受限资源" class="headerlink" title="21.2 共享受限资源"></a>21.2 共享受限资源</h2><h3 id="21-2-1-解决共享资源竞争"><a href="#21-2-1-解决共享资源竞争" class="headerlink" title="21.2.1 解决共享资源竞争"></a>21.2.1 解决共享资源竞争</h3><p>对于应该什么时候同步的问题，应该运用Brain的同步规则：<strong>如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上一次被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须使用相同的监视器同步。</strong></p><h3 id="21-2-2-原子性与易变性"><a href="#21-2-2-原子性与易变性" class="headerlink" title="21.2.2 原子性与易变性"></a>21.2.2 原子性与易变性</h3><p>在线程中，“原子操作不需要进行同步控制”是一个不正确的认识，原子性可以应用于除<code>long</code>和<code>double</code>之外的所有基本类型之上的“简单操作”。对于读写除long和double之外的基本类型变量这样的操作，可以保证它们会被当作不可分(原子)的操作来操作内存，但是JVM可以将64位(long和double)的读写当作两个分离的32位操作来执行，这就产生了一个在读取和写入操作中间发生上下文切换，从而导致不同的任务可以看到不正确结果的可能性，但是当定义long和double变量时，如果使用<code>volatile</code>关键字，就会获得原子性。</p><p>volatile关键字确保了应用中的可视性，如果将几个域声明为volatile，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改，即便用了本地缓存，情况也如此，volatile域会立即被写入到主存中，而读取操作就发生在主存中。</p><h3 id="21-2-3-线程本地存储"><a href="#21-2-3-线程本地存储" class="headerlink" title="21.2.3 线程本地存储"></a>21.2.3 线程本地存储</h3><p>防止任务在共享资源上产生冲突的一种方式是根除对变量的共享，线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。因此，如果有5个线程都要使用变量<code>x</code>所表示的对象，那线程本地存储就会生成5个用于<code>x</code>的不同的存储块，更重要的是，它们使得我们可以将状态与线程关联起来。</p><h4 id="21-2-4-在阻塞时终结"><a href="#21-2-4-在阻塞时终结" class="headerlink" title="21.2.4 在阻塞时终结"></a>21.2.4 在阻塞时终结</h4><p><strong>线程状态</strong></p><p>一个线程可以处于以下四种状态：</p><ol><li>新建(new)：当线程被创建时，它只会短暂处于这个状态。此时它已经分配了必须的系统资源，并执行了初始化，此刻线程已经有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态。</li><li>就绪(Runnable)：在这种状态下，只要调度器把时间片分配给线程，线程就可以运行。也就是说，在任意时刻，线程可以运行也可以不运行。只要调度器能分配时间片给线程。它就可以运行，这不同于死亡和阻塞状态。</li><li>阻塞(Block)：线程能够运行，但有某个条件阻止它运行。当线程处于阻塞状态时，调度器将忽略线程，不会分配给线程任何CPU时间，直到线程重新进入就绪状态，它才有可能执行操作。</li><li>死亡(Dead)：处于死亡或终止状态的线程将不再是可调度的。并且再也不会得到CPU时间，它的任务已结束，或不再是可运行的。任务死亡的通常方式是从<code>run()</code>方法返回。但是任务的线程还可以被中断。</li></ol><p><strong>进入阻塞状态</strong></p><p>一个任务进入阻塞状态，可能有以下原因：</p><ol><li>通过调用<code>sleep(milliseconds)</code>使任务进入休眠状态，在这种情况下，任务在指定的时间内不会运行。</li><li>通过调用<code>wait()</code>使线程挂起。直到线程得到了<code>notify()</code>或<code>notifyAll()</code>消息（或SE5的<code>signal()</code>或<code>signalAll()</code>消息），线程才会进入就绪状态</li><li>任务在等待某个输入/输出完成</li><li>任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于并发&quot;&gt;&lt;a href=&quot;#关于并发&quot; class=&quot;headerlink&quot; title=&quot;关于并发&quot;&gt;&lt;/a&gt;关于并发&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;为什么需要并发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编程问题中的很多部分都可以通过使用顺序编程来解决，顺序编程，就是程序中的所有事物在任意时刻都只能执行一个步骤。然而对于某些问题，如果能够并行地执行程序中的多个部分，会非常高效而且方便，这些部分要么看起来在并发地执行，要么在多处理器的环境下可以同时执行。并行编程可以是程序执行速度得到极大提高。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://balderdasher.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://balderdasher.github.io/tags/java/"/>
    
      <category term="读书笔记" scheme="https://balderdasher.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》第20章-注解</title>
    <link href="https://balderdasher.github.io/2017/06/02/thinking-in-java-annotation/"/>
    <id>https://balderdasher.github.io/2017/06/02/thinking-in-java-annotation/</id>
    <published>2017-06-02T03:11:05.000Z</published>
    <updated>2021-09-29T06:04:29.570Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>注解(也被称为<em>元数据</em>)为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据</strong></p></blockquote><a id="more"></a><h2 id="20-1-基本语法"><a href="#20-1-基本语法" class="headerlink" title="20.1 基本语法"></a>20.1 基本语法</h2><p>下面的写法很少见吧:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Executing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Test</span> <span class="function"><span class="keyword">void</span> <span class="title">testExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>@Test</code>的位置有点奇怪，平常不都是放在方法上面的吗，其实注解<code>@Test</code>可以与任何修饰符共同作用于方法，例如<code>public</code>、<code>static</code>或<code>void</code>，被注解的方法与其他的方法没有区别，从语法角度看，注解的使用方式几乎与修饰符的使用一模一样。</p><h3 id="20-1-1-定义注解"><a href="#20-1-1-定义注解" class="headerlink" title="20.1.1 定义注解"></a>20.1.1 定义注解</h3><p>下面是前面的程序用到的<code>@Test</code>注解的定义，注解的定义看起来很像接口的定义。事实上，与其他任何Java接口一样，注解也将会编译成class文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解定义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-26 14:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了@符号，<code>@Test</code>的定义很像一个空的接口，定义注解时，会需要一些<code>元注解</code>（meta-annotation）,如<code>@Target</code>和<code>@Retention</code>。它们定含义分别是：</p><ul><li>@Target用来定义注解将用于什么地方（例如是一个方法或者一个属性）。</li><li>@Retention用来定义该注解在哪一个级别可用，级别有三个：源代码（SOURCE）、类文件中（CLASS）和运行时（RUNTIME）。</li></ul><p>在注解中一般都会包含一些元素表示某些值，当分析处理注解时，程序或工具可以利用这些值，注解的元素看起来就像接口的方法，不同的是注解中可以为其指定默认值。</p><p>没有元素的注解称为<strong>标记注解</strong>，上面的<code>@Test</code>就是一个标记注解。</p><p>下面是一个简单的注解，可以用来跟踪一个项目中的用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-26 14:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以下类中，有三个方法使用了此注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * "<span class="doctag">@UseCase</span>"注解的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-26 14:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtil</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">47</span>, description = <span class="string">"密码必须包含至少一位数字"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validatePassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (password.matches(<span class="string">"\\w*\\d\\w*"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">48</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encryptPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(password).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkForNewPassword</span><span class="params">(List&lt;String&gt; prevPasswords, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !prevPasswords.contains(password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，注解的元素在使用时表现为<code>名-值对</code>的形式，并需要置于<code>@UseCase</code>声明之后的括号内，在使用时如果没有给出某个元素的值，则使用这个元素的默认值。</p><h3 id="20-1-2-元注解"><a href="#20-1-2-元注解" class="headerlink" title="20.1.2 元注解"></a>20.1.2 元注解</h3><p>Java目前只内置了三种标准注解（<code>@OverRide</code>、<code>@Deprecated</code>、<code>@SuppressWarning</code>），以及四种元注解。元注解专门负责注解其他注解：</p><table><thead><tr><th style="text-align:left">元注解</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">@Target</td><td style="text-align:left">表示该注解可以用于什么地方。可能的<code>ElementType</code>参数包括：<br>CONSTRUCTOR：构造器的声明<br>FIELD：域声明（包括enum实例）<br>LOCAL_VARIABLE：局部变量声明<br>METHOD：方法声明<br>PACKAGE：包声明<br>PARAMETER：参数声明<br>TYPE：类、接口（包括注解类型）或enum声明</td></tr><tr><td style="text-align:left">@Retention</td><td style="text-align:left">表示需要在什么级别保存该注解信息。可选的<code>RetentionPolicy</code>参数包括：<br>SOURCE：注解将被编译器丢弃<br>CLASS：注解在class文件中可用，但会被VM丢弃<br>RUNTIME：VM将在运行期也保留注解，因此可以通过反射机制读取注解信息</td></tr><tr><td style="text-align:left">@Documented</td><td style="text-align:left">将此注解包含在Javadoc中</td></tr><tr><td style="text-align:left">@Inherited</td><td style="text-align:left">允许子类继承父类中的注解</td></tr></tbody></table><h2 id="20-2-编写注解处理器"><a href="#20-2-编写注解处理器" class="headerlink" title="20.2 编写注解处理器"></a>20.2 编写注解处理器</h2><p>一下是一个简单的注解注解处理器，用来查找@UseCase标记，提供了一组id值，它会列出在<code>PasswrodUtil</code>中找到的用例，以及缺失的用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter20;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-26 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseTracker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackUseCases</span><span class="params">(List&lt;Integer&gt; useCases,Class&lt;?&gt; c1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Method m:c1.getDeclaredMethods())&#123;</span><br><span class="line">            UseCase uc = m.getAnnotation(UseCase.class);</span><br><span class="line">            <span class="keyword">if</span> (uc != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Found Use Case："</span> + uc.id() + <span class="string">" "</span> + uc.description());</span><br><span class="line">                useCases.remove(<span class="keyword">new</span> Integer(uc.id()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : useCases)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Warning：Missing use case-"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; useCases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(useCases,<span class="number">47</span>,<span class="number">48</span>,<span class="number">49</span>,<span class="number">50</span>);</span><br><span class="line">        trackUseCases(useCases,PasswordUtil.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Found Use Case：49 检查是不是新的密码</span><br><span class="line">Found Use Case：48 no description</span><br><span class="line">Found Use Case：47 密码必须包含至少一位数字</span><br><span class="line">Warning：Missing use case-50</span><br></pre></td></tr></table></figure><h3 id="20-2-1-注解元素"><a href="#20-2-1-注解元素" class="headerlink" title="20.2.1 注解元素"></a>20.2.1 注解元素</h3><p>注解元素可用的类型如下所示：</p><ul><li>所有基本类型(int、float、boolean等)</li><li>String</li><li>enum</li><li>Annotation</li><li>以上类型的数组</li></ul><p>如果使用了以上类型之外的其他类型，编译器就会报错，包括任何包装类型，注解可以嵌套。</p><h3 id="20-2-2-默认值限制"><a href="#20-2-2-默认值限制" class="headerlink" title="20.2.2 默认值限制"></a>20.2.2 默认值限制</h3><p>编译器对注解中元素的默认值有严格的限制：元素不能有不确定的值，要么具有默认值，要么使用注解时提供元素的值。</p><p>另外，对于非基本类型的元素，无论是声明还是在注解接口中定义默认值时，都不能以null作为其值，这个约束使得处理器很难表现一个元素的存在或缺失的状态，为了绕开这个约束，可以定义一些特殊的值，例如<code>空字符串</code>或者<code>负数</code>，以此来表示某个元素不存在</p><h3 id="20-2-3-生成外部文件"><a href="#20-2-3-生成外部文件" class="headerlink" title="20.2.3 生成外部文件"></a>20.2.3 生成外部文件</h3><p>有些框架需要一些额外的信息才能与源代码协同工作，比如hibernate的hbm映射文件，这些描述文件脱离了源代码之外，所以在我们编写了Javabean之后还要忍受编写xml文件的烦恼，于此同时，同一个类拥有了两个单独的信息源，经常也会导致代码同步问题。</p><p>每当上述情况出现的时候，注解的价值就体现出来了，比如我们希望提供一些基本的对象/关系映射功能，能够自动生成数据库表，我们可以抛弃xml描述文件的方式，使用注解，将所有的信息保留在JavaBean源文件中，以下就是用注解的实现方式：</p><p>首先，需要一个新的注解，用来定义与Bean关联的数据库表的名字，以下的注解告诉处理器，你需要为我生成一个数据库表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库表的注解，用于实体bean类上，说明该实体生成的数据库表信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-26 16:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是javaBean的注解，用于描述JavaBean中的属性与生成数据库表中的字段的一些联系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表字段约束注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-26 16:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Constraints &#123;</span><br><span class="line">    <span class="comment">/* 是否主键 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">primaryKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 是否允许为空 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allowNull</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 是否唯一 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sql类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-26 16:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sql类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-26 16:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLInteger &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是一个简单的Bean定义，使用了以上这些注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JavaBean</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-26 16:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"MEMBER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SQLString</span>(<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="meta">@SQLString</span>(<span class="number">50</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="meta">@SQLInteger</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@SQLString</span>(value = <span class="number">30</span>, constraints = <span class="meta">@Constraints</span>(primaryKey = <span class="keyword">true</span>))</span><br><span class="line">    <span class="keyword">private</span> String handle;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> memberCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-2-4-注解不支持继承"><a href="#20-2-4-注解不支持继承" class="headerlink" title="20.2.4 注解不支持继承"></a>20.2.4 注解不支持继承</h3><p>不能使用<code>extends</code>关键字来继承某个@interface。也就是说：Java在定义注解时，不能继承自某个其他的注解。</p><h3 id="20-2-5-实现处理器"><a href="#20-2-5-实现处理器" class="headerlink" title="20.2.5 实现处理器"></a>20.2.5 实现处理器</h3><p>以下是一个针对上面对象/关系映射注解处理器的例子，将读取一个类文件，检查其中的数据库注解，并生成用来创建数据库的SQL语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter20.framework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-07-26 17:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableCreator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; beanClasses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(beanClasses, Member.class);</span><br><span class="line">        process(beanClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Class&lt;?&gt;&gt; beanClasses)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Class c1 : beanClasses) &#123;</span><br><span class="line">            Class&lt;?&gt; c = Class.forName(c1.getName());</span><br><span class="line">            DBTable dbTable = c.getAnnotation(DBTable.class);</span><br><span class="line">            <span class="keyword">if</span> (dbTable == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"No DBTable annotations in class "</span> + c.getName());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String tableName = dbTable.name();</span><br><span class="line">            <span class="keyword">if</span> (tableName.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                tableName = c.getSimpleName().toUpperCase();</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;String&gt; columnDefs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Field field : c.getDeclaredFields()) &#123;</span><br><span class="line">                String columnName;</span><br><span class="line">                Annotation[] anns = field.getDeclaredAnnotations();</span><br><span class="line">                <span class="keyword">if</span> (anns.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (field.isAnnotationPresent(SQLInteger.class)) &#123;</span><br><span class="line">                    SQLInteger sInt = field.getAnnotation(SQLInteger.class);</span><br><span class="line">                    <span class="keyword">if</span> (sInt.name().length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                        columnName = field.getName().toUpperCase();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        columnName = sInt.name();</span><br><span class="line">                    &#125;</span><br><span class="line">                    columnDefs.add(columnName + <span class="string">" INT"</span> + getConstraints(sInt.constraints()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (field.isAnnotationPresent(SQLString.class)) &#123;</span><br><span class="line">                    SQLString sString = field.getAnnotation(SQLString.class);</span><br><span class="line">                    <span class="keyword">if</span> (sString.name().length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                        columnName = field.getName().toUpperCase();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        columnName = sString.name();</span><br><span class="line">                    &#125;</span><br><span class="line">                    columnDefs.add(columnName + <span class="string">" VARCHAR("</span> + sString.value() + <span class="string">")"</span> + getConstraints(sString.constraints()));</span><br><span class="line">                &#125;</span><br><span class="line">                StringBuilder createCommand = <span class="keyword">new</span> StringBuilder(<span class="string">"CREATE TABLE "</span> + tableName + <span class="string">"("</span>);</span><br><span class="line">                <span class="keyword">for</span> (String columnDef : columnDefs) &#123;</span><br><span class="line">                    createCommand.append(<span class="string">"\n   "</span>).append(columnDef).append(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                String tableCreate = createCommand.substring(<span class="number">0</span>, createCommand.length() - <span class="number">1</span>) + <span class="string">");"</span>;</span><br><span class="line">                System.out.println(<span class="string">"Table Creation SQL for "</span> + c.getName() + <span class="string">" is : \n"</span> + tableCreate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getConstraints</span><span class="params">(Constraints con)</span> </span>&#123;</span><br><span class="line">        String constraints = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (!con.allowNull()) &#123;</span><br><span class="line">            constraints += <span class="string">" NOT NULL"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (con.primaryKey()) &#123;</span><br><span class="line">            constraints += <span class="string">" PRIMARY KEY"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (con.unique()) &#123;</span><br><span class="line">            constraints += <span class="string">" UNIQUE"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constraints;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Table Creation SQL for com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter20.framework.Member is : </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">   FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>));</span><br><span class="line">Table Creation SQL for com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter20.framework.Member is : </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">   FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">   LASTNAME <span class="built_in">VARCHAR</span>(<span class="number">50</span>));</span><br><span class="line">Table Creation SQL for com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter20.framework.Member is : </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">   FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">   LASTNAME <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">   AGE <span class="built_in">INT</span>);</span><br><span class="line">Table Creation SQL for com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter20.framework.Member is : </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">   FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">   LASTNAME <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">   AGE <span class="built_in">INT</span>,</span><br><span class="line">   HANDLE <span class="built_in">VARCHAR</span>(<span class="number">30</span>) PRIMARY <span class="keyword">KEY</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注解(也被称为&lt;em&gt;元数据&lt;/em&gt;)为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="https://balderdasher.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://balderdasher.github.io/tags/java/"/>
    
      <category term="读书笔记" scheme="https://balderdasher.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》第19章-枚举类型</title>
    <link href="https://balderdasher.github.io/2017/06/01/thinking-in-java-enum/"/>
    <id>https://balderdasher.github.io/2017/06/01/thinking-in-java-enum/</id>
    <published>2017-06-01T03:11:05.000Z</published>
    <updated>2021-09-29T06:04:29.570Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关键字enum可以将一组具名的值的有限集合创建为一种新的类型，这些具名的值可以作为常规的程序组件使用，这就是枚举类型的本质。</p></blockquote><a id="more"></a><h2 id="19-1-enum基本特性"><a href="#19-1-enum基本特性" class="headerlink" title="19.1 enum基本特性"></a>19.1 enum基本特性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter19;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举类功能演示</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Shrubbery s:Shrubbery.values())&#123;</span><br><span class="line">            <span class="comment">// 值在定义时候的顺序,从0开始</span></span><br><span class="line">            System.out.println(s + <span class="string">" ordinal: "</span> + s.ordinal());</span><br><span class="line">            <span class="comment">// enum类实现了Comparable接口，还实现了Serializable接口</span></span><br><span class="line">            System.out.println(s.compareTo(Shrubbery.CRAWLING));</span><br><span class="line">            <span class="comment">// 使用==来比较enum实例，equals()和hashCode()方法由编译器自动提供</span></span><br><span class="line">            System.out.println(s == Shrubbery.CRAWLING);</span><br><span class="line">            System.out.println(s.equals(Shrubbery.CRAWLING));</span><br><span class="line">            <span class="comment">// 通过调用getDeclaringClass得到实例所在的enum类</span></span><br><span class="line">            System.out.println(s.getDeclaringClass().getSimpleName());</span><br><span class="line">            System.out.println(s.name());</span><br><span class="line">            System.out.println(<span class="string">"----------------------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从一个字符串构造一个枚举</span></span><br><span class="line">        <span class="keyword">for</span> (String s:<span class="string">"HANGING CRAWLING GROUND"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            Shrubbery shrub = Enum.valueOf(Shrubbery.class,s);</span><br><span class="line">            System.out.println(shrub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Shrubbery&#123;GROUND,CRAWLING,HANGING&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">GROUND ordinal: 0</span><br><span class="line">-1</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">Shrubbery</span><br><span class="line">GROUND</span><br><span class="line">----------------------</span><br><span class="line">CRAWLING ordinal: 1</span><br><span class="line">0</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">Shrubbery</span><br><span class="line">CRAWLING</span><br><span class="line">----------------------</span><br><span class="line">HANGING ordinal: 2</span><br><span class="line">1</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">Shrubbery</span><br><span class="line">HANGING</span><br><span class="line">----------------------</span><br><span class="line">HANGING</span><br><span class="line">CRAWLING</span><br><span class="line">GROUND</span><br></pre></td></tr></table></figure></p><h2 id="19-2-向enum中添加新方法"><a href="#19-2-向enum中添加新方法" class="headerlink" title="19.2 向enum中添加新方法"></a>19.2 向enum中添加新方法</h2><blockquote><p>除了不能继承另一个<code>enum</code>外，我们可以将<code>enum</code>看做一个常规的类，可以向其中添加新方法，甚至可以有<code>main()</code>方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum中添加新方法</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OfferType &#123;</span><br><span class="line">    <span class="comment">// 实例的定义必须在最方法或者属性之前，否则会编译错误</span></span><br><span class="line">    FOOD(<span class="string">"美食"</span>),</span><br><span class="line">    HAPPY(<span class="string">"娱乐"</span>),</span><br><span class="line">    STAY(<span class="string">"住宿"</span>),</span><br><span class="line">    SHOPPING(<span class="string">"购物"</span>),</span><br><span class="line">    TRIP(<span class="string">"出行"</span>),</span><br><span class="line">    LIFE(<span class="string">"生活服务"</span>),</span><br><span class="line">    OTHER(<span class="string">"其它"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器必须是private的或者是包访问权限(ide已建议为包访问权限)的</span></span><br><span class="line">    OfferType(String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enum中可以有main()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (OfferType o : OfferType.values()) &#123;</span><br><span class="line">            System.out.println(o + <span class="string">": "</span> + o.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FOOD: 美食</span><br><span class="line">HAPPY: 娱乐</span><br><span class="line">STAY: 住宿</span><br><span class="line">SHOPPING: 购物</span><br><span class="line">TRIP: 出行</span><br><span class="line">LIFE: 生活服务</span><br><span class="line">OTHER: 其它</span><br></pre></td></tr></table></figure></p><p>从程序中可以看出，当为enum添加属性或者方法时，正确的姿势是在定义完实例之后加上分号，然后再添加属性或者方法，如果在实例之前出现任何属性和方法的定义，将会得到编译错误，另外，enum的构造器建议为private或者default的，因为即使我们将之声明为public的，我们也只能在enum定义的内部使用其构造器创建enum实例。一旦enum的定义结束。编译器就不允许再使用其构造器来创建任何实例了，所以所以声明为public是毫无意义的。</p><h2 id="19-3-switch语句中的enum"><a href="#19-3-switch语句中的enum" class="headerlink" title="19.3 switch语句中的enum"></a>19.3 switch语句中的enum</h2><p>为什么switch语句中可以使用enum呢？</p><p>一般来说，在switch中只能使用整数值，而枚举类型本身就具备整数值的次序，并且可以通过<code>ordinal()</code>方法取得次序，所以肯定是编译器帮我们做了某些工作让switch语句使用了enum中的整数值次序，所以我们才可以在switch语句中使用enum。</p><p>一个红绿灯（小型状态机）的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * switch语句中的enum</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> Signal &#123;</span><br><span class="line">    GREEN, YELLOW, RED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficLight</span> </span>&#123;</span><br><span class="line">    Signal color = Signal.RED;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">            <span class="comment">// 在case语句中不必使用enum类型来修饰一个enum实例如此处不必用Signal.RED</span></span><br><span class="line">            <span class="keyword">case</span> RED:</span><br><span class="line">                color = Signal.GREEN;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GREEN:</span><br><span class="line">                color = Signal.YELLOW;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YELLOW:</span><br><span class="line">                color = Signal.RED;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"The traffic light is "</span> + color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TrafficLight t = <span class="keyword">new</span> TrafficLight();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">            t.change();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The traffic light is RED</span><br><span class="line">The traffic light is GREEN</span><br><span class="line">The traffic light is YELLOW</span><br><span class="line">The traffic light is RED</span><br><span class="line">The traffic light is GREEN</span><br><span class="line">The traffic light is YELLOW</span><br><span class="line">The traffic light is RED</span><br></pre></td></tr></table></figure></p><h2 id="19-4-神秘的values"><a href="#19-4-神秘的values" class="headerlink" title="19.4 神秘的values()"></a>19.4 神秘的values()</h2><p>编译器为我们创建的enum类都继承自Enum类，但从Enum类的源码来看，它并没有<code>values()</code>方法，但是为什么我们又可以使用这个方法呢？难道存在某种“隐藏的”方法吗？</p><p>利用反射机制已经证明：<code>values()</code>方法是由编译器添加的<code>static</code>方法，而且编译器还添加了<code>valueOf()</code>方法，这个valueOf()与Enum中原有的valueOf()不同，这个方法只需一个参数，而enum原有的需要两个参数。</p><h2 id="19-5-实现，而非继承"><a href="#19-5-实现，而非继承" class="headerlink" title="19.5 实现，而非继承"></a>19.5 实现，而非继承</h2><p>因为所有的enum都继承自<code>java.lang.Enum</code>类，因为Java不支持多重继承，所以我们新建enum时不能再继承其他的类，但是我们可以同时实现一个或多个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NotifyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doNotify</span><span class="params">(Model model)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNotify</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> NoticeType &#123;</span><br><span class="line">    SUCCESS(<span class="string">"成功"</span>,<span class="string">"成功"</span>),</span><br><span class="line">    ERROR(<span class="string">"错误"</span>,<span class="string">"错误"</span>),</span><br><span class="line">    WARN(<span class="string">"警告"</span>,<span class="string">"警告"</span>),</span><br><span class="line">    INFO(<span class="string">"提示"</span>,<span class="string">"提示"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    NoticeType(String name, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** getters and setters **/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例通知，用于提示</span></span><br><span class="line"><span class="comment"> * 0:弹出框和页面提示均需设置"infoTip"参数用于展示提示信息</span></span><br><span class="line"><span class="comment"> * 1:弹出框提示须设置"type"参数用于artDialog展示不同的样式、"redirectUrl"参数可选决定关闭弹出框时的跳转链接(x)</span></span><br><span class="line"><span class="comment"> * 2:页面提示时设置"title"参数设置页面的title属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrdios</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Notification implements NotifyInterface &#123;</span><br><span class="line">NOTICE &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">            model.addAttribute(<span class="string">"infoTip"</span>, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">"infoTip"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台通知页面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACK_NOTIFY_VIEW = <span class="string">"info"</span>;</span><br><span class="line">    <span class="keyword">private</span> NoticeType type;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String infoTip;</span><br><span class="line">    <span class="keyword">private</span> String redirectUrl;</span><br><span class="line">    <span class="keyword">private</span> String callBack;<span class="comment">//附加回调参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> historyGo = -<span class="number">1</span>;<span class="comment">//页面中history.go(int)的参数，仅当redirectUrl为空时此字段才有用，默认-1，即回退1个历史记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知后擦黑板，防止当前通知影响下一个通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.callBack = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.title = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.infoTip = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.redirectUrl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.historyGo = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCallBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Notification <span class="title">setCallBack</span><span class="params">(String callBack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callBack = callBack;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfoTip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> infoTip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Notification <span class="title">setInfoTip</span><span class="params">(String infoTip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.infoTip = infoTip;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRedirectUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redirectUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Notification <span class="title">setRedirectUrl</span><span class="params">(String redirectUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redirectUrl = redirectUrl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Notification <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NoticeType <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Notification <span class="title">setType</span><span class="params">(NoticeType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHistoryGo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> historyGo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Notification <span class="title">setHistoryGo</span><span class="params">(<span class="keyword">int</span> historyGo)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.historyGo = historyGo;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序是我为Java web后台设计的一个通知程序，例如后台成功添加一条数据以弹出框形式提示保存成功，我们在程序中保存完数据之后携带一个通知跳转到设置的通知页面<code>info.html</code>，此页面上只有一段用于弹出框的js，弹出框的各种参数来源于从通知中取出来的参数，比如弹出框显示的图标取决于通知的类型等。下面是使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == activity) &#123;</span><br><span class="line">    Notification.NOTICE.setType(NoticeType.ERROR).setInfoTip(<span class="string">"活动不存在！"</span>).doNotify(model);</span><br><span class="line">    <span class="keyword">return</span> Notification.BACK_NOTIFY_VIEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从程序中可以看到，enum可以实现一个或多个接口，如果实现了某个接口，那么所有enum的实例都必须实现接口中的所有方法（上面是单例）。</p><h2 id="19-6-使用接口组织枚举"><a href="#19-6-使用接口组织枚举" class="headerlink" title="19.6 使用接口组织枚举"></a>19.6 使用接口组织枚举</h2><p>有时候我们希望使用子类将一个enum中的元素进行分组，在一个接口内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚举元素分类组织的目的，比如想用enum来表示不同类别的商品，同时还希望每个enum元素仍然保持<code>Goods</code>类型，可以这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口组织枚举，实现接口是enum子类化的唯一办法</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Office implements Goods &#123;COMPUTER, GAME;&#125;</span><br><span class="line">    <span class="keyword">enum</span> Food implements Goods &#123;FRUIT, SEAFOOD, MEAT, WINE&#125;</span><br><span class="line">    <span class="keyword">enum</span> Book implements Goods &#123;LIFE, EDUCATION, TECHNOLOGY&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Goods goods = Goods.Office.COMPUTER;</span><br><span class="line">        goods = Goods.Food.FRUIT;</span><br><span class="line">        goods = Goods.Book.TECHNOLOGY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-7-使用EnumSet替代标志"><a href="#19-7-使用EnumSet替代标志" class="headerlink" title="19.7 使用EnumSet替代标志"></a>19.7 使用EnumSet替代标志</h2><blockquote><p>Set是一种包含不重复对象的集合，enum也要求其中的成员是唯一的，所以enum看起来也具有集合的行为。但由于不能从enum中删除或添加元素，所以它只能算是用处不大的集合，Java引入<code>EnumSet</code>是为了通过enum创建一种替代传统基于<code>int</code>“标志位”的替代品，这种标志可以用来表示某种“开/关”信息，不过使用这种标志最终操作的只是一些<code>bit</code>，而不是这些bit想要表达的概念，所以也很容易写出令人难以理解的代码。</p></blockquote><p>EnumSet因为必须与非常高效的bit标志竞争，所以它非常快。它的优点在于：在说明一个二进制位是否存在时，具有更好的表达能力，并且无需担心性能。</p><p>EnumSet中的元素必须来自于一个enum，下面的例子表示大楼中警报器的安放位置,然后用<code>EnumSet</code>来跟踪报警器的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大楼中警报传感器的安放位置</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> AlarmPoints &#123;</span><br><span class="line">    STAIR1, STAIR2, LOBBY, OFFICE1, OFFICE2, OFFICE3, OFFICE4, BATHROOM, UTILITY, KITCHEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EnumSet跟踪警报器状态</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumSet&lt;AlarmPoints&gt; points = EnumSet.noneOf(AlarmPoints.class); <span class="comment">// empty set</span></span><br><span class="line">        points.add(AlarmPoints.BATHROOM);</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points.addAll(EnumSet.of(AlarmPoints.STAIR1, AlarmPoints.STAIR2, AlarmPoints.KITCHEN));</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points = EnumSet.allOf(AlarmPoints.class);</span><br><span class="line">        points.removeAll(EnumSet.of(AlarmPoints.STAIR1, AlarmPoints.STAIR2, AlarmPoints.KITCHEN));</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points.removeAll(EnumSet.range(AlarmPoints.OFFICE1, AlarmPoints.OFFICE4));</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points = EnumSet.complementOf(points);<span class="comment">//取补集</span></span><br><span class="line">        System.out.println(points);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[BATHROOM]</span><br><span class="line">[STAIR1, STAIR2, BATHROOM, KITCHEN]</span><br><span class="line">[LOBBY, OFFICE1, OFFICE2, OFFICE3, OFFICE4, BATHROOM, UTILITY]</span><br><span class="line">[LOBBY, BATHROOM, UTILITY]</span><br><span class="line">[STAIR1, STAIR2, OFFICE1, OFFICE2, OFFICE3, OFFICE4, KITCHEN]</span><br></pre></td></tr></table></figure></p><p>观察以上程序的输出也可以看出一个规律：无论以什么样的顺序从EnumSet中添加或删除元素，最终元素的顺序与enum中的保持一致性。</p><h2 id="19-8-使用EnumMap"><a href="#19-8-使用EnumMap" class="headerlink" title="19.8 使用EnumMap"></a>19.8 使用EnumMap</h2><blockquote><p>EnumMap是一种特殊的Map，它要求其中的键(key)必须来自一个enum。由于enum本身的限制，所以EnumMap在内部可由数组实现，所以EnumMap的速度很快，我们可以使用enum实例在EnumMap中进行查找操作，但也只能将enum的实例作为键来调用put()方法，其他的操作跟一样的Map差不多。</p></blockquote><p>以下是一个<strong>命令设计模式</strong>的用法，命令设计模式首先需要一个只有单一方法的接口，然后从该接口实现具有各自不同行为的多个子类，然后我们就可以构造命令对象，并在需要的时候使用它们：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用EnumMap</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMaps</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumMap&lt;AlarmPoints,Command&gt; em = <span class="keyword">new</span> EnumMap&lt;&gt;(AlarmPoints.class);</span><br><span class="line">        em.put(AlarmPoints.KITCHEN, <span class="keyword">new</span> Command() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"厨房着火了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        em.put(AlarmPoints.BATHROOM, <span class="keyword">new</span> Command() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"浴室起火了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;AlarmPoints,Command&gt; e:em.entrySet())&#123;</span><br><span class="line">            System.out.println(e.getKey());</span><br><span class="line">            e.getValue().action();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            em.get(AlarmPoints.UTILITY).action();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BATHROOM</span><br><span class="line">浴室起火了</span><br><span class="line">KITCHEN</span><br><span class="line">厨房着火了</span><br><span class="line">java.lang.NullPointerException</span><br></pre></td></tr></table></figure></p><h2 id="19-9-常量相关的方法"><a href="#19-9-常量相关的方法" class="headerlink" title="19.9 常量相关的方法"></a>19.9 常量相关的方法</h2><p>Java的enum允许我们为enum实例编写方法，从而为每个enum实例赋予各自不同的行为，实现常量相关的方法有两种方案：</p><ol><li>为enum定义一个或多个<code>abstract</code>方法，然后为每个enum实例实现该抽象方法。</li><li>使enum实现一个或多个接口，然后在每个enum实例中实现接口中的方法(10.5节已演示)。</li></ol><p>综合来看，第一种方案比较灵活，因为它不需要新建接口，直接在enum中定义每个实例需要实现的抽象方法就可以了，下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常量相关的方法</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SystemConfig &#123;</span><br><span class="line">    DATE_TIME &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DateFormat.getDateInstance().format(<span class="keyword">new</span> Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    CLASSPATH &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.getenv(<span class="string">"CLASSPATH"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    VERSION &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.getProperty(<span class="string">"java.version"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SystemConfig config : values()) &#123;</span><br><span class="line">            System.out.println(config.getInfo());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-7-22</span><br><span class="line">.;C:\Program Files\Java\jdk1.7.0_65\lib\dt.jar;C:\Program Files\Java\jdk1.7.0_65\lib\tools.jar;</span><br><span class="line">1.7.0_65</span><br></pre></td></tr></table></figure></p><p>在以上代码中，通过相应的enum实例调用其上的方法，这也成为<strong>表驱动的代码</strong>，与上面的命令设计模式有相似之处。</p><p>每个enum实例具备自己独特的行为，似乎说明每个enum实例就像一个独特的类，以上例子中enum实例似乎被当做其“超类”<code>SystemConfig</code>来使用，在调用<code>getInfo()</code>方法时，体现出多态行为。但是enum实例与类的相似之处也仅限于此了，事实证明我们并不能真的将enum实例作为一个类型来使用。虽然如此，还是可以将其看做是类。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关键字enum可以将一组具名的值的有限集合创建为一种新的类型，这些具名的值可以作为常规的程序组件使用，这就是枚举类型的本质。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="https://balderdasher.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://balderdasher.github.io/tags/java/"/>
    
      <category term="读书笔记" scheme="https://balderdasher.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》第18章-java io系统</title>
    <link href="https://balderdasher.github.io/2017/05/31/thinking-in-java-io/"/>
    <id>https://balderdasher.github.io/2017/05/31/thinking-in-java-io/</id>
    <published>2017-05-31T03:11:05.000Z</published>
    <updated>2021-09-29T06:04:29.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="18-1-File类"><a href="#18-1-File类" class="headerlink" title="18.1 File类"></a>18.1 File类</h2><p>File类是一个实用类库工具，可以帮助我们处理文件目录问题。File（文件）类既能代表一个特定文件的<em>名称</em>，又能代表一个目录下的一组文件的名称。</p><a id="more"></a><h3 id="18-1-1-目录列表器"><a href="#18-1-1-目录列表器" class="headerlink" title="18.1.1 目录列表器"></a>18.1.1 目录列表器</h3><p>查看一个目录列表有两种方式：</p><ol><li>调用不带参数的<code>list()</code>方法，可以获得File对象包含的全部列表。</li><li>使用“目录过滤器”来获取一个受限列表，如得到所有扩展名为<code>.java</code>的文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listView</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File path = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        String[] list;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            list = path.list();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list = path.list(filter(args[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        <span class="keyword">for</span> (String dirItem : list) &#123;</span><br><span class="line">            System.out.println(dirItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FilenameFilter <span class="title">filter</span><span class="params">(<span class="keyword">final</span> String regex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            <span class="keyword">private</span> Pattern pattern = Pattern.compile(regex);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        listView(<span class="keyword">new</span> String[]&#123;<span class="string">".java"</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，把<code>filter</code>传递给<code>list()</code>使用，使<code>list()</code>可以回调filter中的<code>accept()</code>方法，这种结构称为<strong>回调</strong>，这也是<strong>策略模式</strong>的一种形式：list()实现了基本的功能，按照<code>FilenameFilter</code>的形式提供了这个<strong>策略</strong>，意味着可以传递实现了<code>FilenameFilter</code>接口的任何类的对象，用于选择<code>list()</code>方法的行为方式，策略的目的就是提供了代码行为的灵活性。</p><p>list()方法会为此目录下的每个文件名调用<code>accept()</code>来判断该文件是否包含在内。</p><h2 id="18-2-输入和输出"><a href="#18-2-输入和输出" class="headerlink" title="18.2 输入和输出"></a>18.2 输入和输出</h2><blockquote><p>编程语言的I/O类库中的流是一个抽象的概念，它代表任何有能力产出数据的数据源对象或是有能力接受数据的接收端对象。“流”屏蔽了实际的I/O设备中处理数据的细节。<br>Java的I/O类库分为输入和输出两部分，按照类的功能进行分类，与输入有关的所有类都应该从<code>InputStream</code>继承，而与输出有关的所有类都应该从<code>OutputStream</code>继承。</p></blockquote><h3 id="18-2-1-InputStream类型"><a href="#18-2-1-InputStream类型" class="headerlink" title="18.2.1 InputStream类型"></a>18.2.1 InputStream类型</h3><p>InputStream的作用是用来表示那些从不同数据源产生输入的类，这些数据源包括：</p><ol><li>字节数组</li><li>String对象</li><li>文件</li><li>“管道”，工作方式与实际管道相似（从一端输入，从另一端输出）</li><li>一个由其他种类的流组成的序列，以便我们可以将它们随机合并到一个流内</li><li>其他数据源，如Internet连接等</li></ol><p>每一种数据源都有相应的<code>InputStream</code>子类，<code>FilterInputStream</code>也属于一种InputStream，为“装饰器”(decorator)类提供基类，其中，“装饰器”类可以把属性或有用的借口与输入流连接在一起。</p><p><strong>表18-1 InputStream类型</strong></p><table><thead><tr><th style="text-align:left">类</th><th style="text-align:left">功能</th><th style="text-align:left">构造器参数/如何使用</th></tr></thead><tbody><tr><td style="text-align:left">ByteArrayInputStream</td><td style="text-align:left">允许将内存的缓冲区当做InputStream使用</td><td style="text-align:left">缓冲区，字节将从中取出作为一种数据源：将其与FilterInputStream对象相连以提供有用借口</td></tr><tr><td style="text-align:left">StringBufferInputStream</td><td style="text-align:left">将String转换成InputStream</td><td style="text-align:left">字符串。底层实现实际使用StringBuffer作为一种数据源：将其与FilterInputStream对象相连以提供有用接口</td></tr><tr><td style="text-align:left">FileInputStream</td><td style="text-align:left">用于从文件中读取信息</td><td style="text-align:left">字符串，表示文件名、文件或FileDescriptor对象，作为一种数据源：将其与FilterInputStream对象相连以提供有用接口</td></tr><tr><td style="text-align:left">PipedInputStream</td><td style="text-align:left">产生用于写入相关PipedOutputStream的数据，实现“管道化”概念</td><td style="text-align:left">PipedOutputStream，作为多线程中数据源：将其与FilterInputStream对象相连以提供有用接口</td></tr><tr><td style="text-align:left">SequenceInputStream</td><td style="text-align:left">将两个或多个InputStream对象转换成单一InputStream</td><td style="text-align:left">两个InputStream对象或一个容纳InputStream对象的容器Enumeration，作为一种数据源：将其与FilterInputStream对象相连以提供有用接口</td></tr><tr><td style="text-align:left">FilterInputStream</td><td style="text-align:left">抽象类，作为“装饰器”的接口，其中“装饰器”为其他的InputStream类提供有用功能</td><td style="text-align:left">见表18-3</td></tr></tbody></table><h3 id="18-2-2-OutputStream类型"><a href="#18-2-2-OutputStream类型" class="headerlink" title="18.2.2 OutputStream类型"></a>18.2.2 OutputStream类型</h3><p>该类别的类决定了输出所要去往的目标：字节数组、文件或管道。<code>FilterOutputStream</code>为“装饰器”类提供了一个基类。</p><p><strong>表 18-2 OutputStream类型</strong></p><table><thead><tr><th style="text-align:left">类</th><th style="text-align:left">功能</th><th style="text-align:left">构造器参数/如何使用</th></tr></thead><tbody><tr><td style="text-align:left">ByteArrayOutputStream</td><td style="text-align:left">在内存中创建缓冲区，所有送往“流”的数据都要放在此缓冲区</td><td style="text-align:left">缓冲区初始化尺寸（可选）；用于指定数据的目的地：将其与FilterOutPutStream对象相连以提供有用接口</td></tr><tr><td style="text-align:left">FileOutputStream</td><td style="text-align:left">用于将信息写至文件</td><td style="text-align:left">字符串，表示文件名、文件或FileDescriptor对象；指定数据的目的地：将其与FilterOutPutStream对象相连以提供有用接口</td></tr><tr><td style="text-align:left">PipedOutputStream</td><td style="text-align:left">任何写入其中的信息都会自动作为相关PipedInputStream的输出，实现“管道”概念</td><td style="text-align:left">PipedInputStream；指定用于多线程的数据的目的地：将其与FilterOutPutStream对象相连以提供有用接口</td></tr><tr><td style="text-align:left">FilterOutputStream</td><td style="text-align:left">抽象类，作为“装饰器”的接口，其中“装饰器”为其他OutputStream提供有用功能</td><td style="text-align:left">见表18-4</td></tr></tbody></table><h2 id="18-3-添加属性和有用的接口"><a href="#18-3-添加属性和有用的接口" class="headerlink" title="18.3 添加属性和有用的接口"></a>18.3 添加属性和有用的接口</h2><p>Java的I/O类库需要多种不同功能的组合，所以用到了装饰器模式，这也是io类库里存在<code>filter</code>(过滤器)<br>的原因，抽象类<code>filter</code>是所有装饰器类的基类。但是装饰器有个缺点，它在给我们提供灵活性的同时也增加了代码的复杂性，Java I/O类库操作不便的原因就是我们必须创建许多类——“核心” I/O类型加上所有的装饰器，才能得到我们希望的单个I/O对象。</p><p>FilterInputStream和FilterOutputStream是用来提供装饰器类接口以控制特定输入流（InputStream）和输出流（OutputStream）的两个类。它们分别继承自Java I/O类库中的基类<code>InputStream</code>和<code>OutputStream</code>，这两个类是装饰器的必要条件（以便能为所有正在被装饰的对象提供通用接口）。</p><h3 id="18-3-1-通过FilterInputStream从InputStream读取数据"><a href="#18-3-1-通过FilterInputStream从InputStream读取数据" class="headerlink" title="18.3.1 通过FilterInputStream从InputStream读取数据"></a>18.3.1 通过FilterInputStream从InputStream读取数据</h3><p>FilterInputStream类能够完成两件完全不同的事情。其中<code>DataInputStream</code>允许我们读取不同的基本类型数据以及<code>String</code>对象（所有方法都以“read”开头，如<code>readByte()、readFloat()</code>）。配合相应的<code>DataOutputStream</code>，就可以通过数据“流”将基本数据类型的数据从一个地方迁移到另一个地方。</p><p>其他FilterInputStream类则在内部修改<code>InputStream</code>的行为方式：是否缓冲，是否保留读过的行（允许查询或设置行数），以及是否把单一字符推回输入流等</p><p><strong>表18-3 FilterInputStream类型</strong></p><table><thead><tr><th style="text-align:left">类</th><th style="text-align:left">功能</th><th style="text-align:left">构造器参数/如何使用</th></tr></thead><tbody><tr><td style="text-align:left">DataInputStream</td><td style="text-align:left">与DataOutputStream搭配使用，因此可以按照可移植方式从流读取基本数据类型</td><td style="text-align:left">InputStream；包含用于读取基本类型数据的全部接口</td></tr><tr><td style="text-align:left">BufferedInputStream</td><td style="text-align:left">使用它可以防止每次读取时都进行实际写操作。代表“使用缓冲区”</td><td style="text-align:left">InputStream，可以指定缓冲区大小（可选）；本质上不提供接口，只不过是向进程中添加缓冲区所必需的，与接口对象搭配</td></tr><tr><td style="text-align:left">LineNumberInputStream</td><td style="text-align:left">跟踪输入流中的行号，可调用<code>getLineNumber()</code>和<code>setLineNumber(int)</code></td><td style="text-align:left">InputStream；仅增加了行号，因此可能要与接口对象搭配使用</td></tr><tr><td style="text-align:left">PushBackInputStream</td><td style="text-align:left">具有“能弹出一个字节的缓冲区”。因此可以将读到的最后一个字符回退</td><td style="text-align:left">InputStream；通常作为编译器的扫描器，因为Java编译器的需要所以出现此类，我们永远不会用到</td></tr></tbody></table><h3 id="18-3-2-通过FilterOutputStream向OutPutStream写入"><a href="#18-3-2-通过FilterOutputStream向OutPutStream写入" class="headerlink" title="18.3.2 通过FilterOutputStream向OutPutStream写入"></a>18.3.2 通过FilterOutputStream向OutPutStream写入</h3><p>与<code>DataInputStream</code>对应的<code>DataOutputStream</code>可以将各种基本数据类型以及String对象格式化输出到“流”中，这样一来，任何机器上的任何<code>DataInputStream</code>都能够读取它们。所有方法都以“write”开头，如<code>writeByte()</code>、<code>writeFloat()</code>等。</p><p><strong>表18-4 FilterOutputStream类型</strong></p><table><thead><tr><th style="text-align:left">类</th><th style="text-align:left">功能</th><th style="text-align:left">构造器参数/如何使用</th></tr></thead><tbody><tr><td style="text-align:left">DataOutputStream</td><td style="text-align:left">与<code>DataInputStream</code>搭配使用，因此可以按照可移植方式向流中写入基本类型数据</td><td style="text-align:left">OutputStream；包含用于写入基本类型数据的全部接口</td></tr><tr><td style="text-align:left">PrintStream</td><td style="text-align:left">用于产生格式化输出。其中<code>DataOutputStream</code>处理数据的<code>存储</code>，<code>PrintStream</code>处理显示</td><td style="text-align:left">OutputStream，可以用Boolean值指示是否在每次换行时清空缓存（可选）应该是对<code>OutputStream</code>对象的“final”封装，可能会经常使用</td></tr><tr><td style="text-align:left">BufferedOutputStream</td><td style="text-align:left">使用它以避免每次发送数据是都要进行实际的写操作。代表“使用缓冲区”可以使用<code>flush()</code>清空缓冲区</td><td style="text-align:left">OutputStream，可以指定缓冲区大小（可选）；本质上并不提供接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配</td></tr></tbody></table><h2 id="18-4-Reader和Writer"><a href="#18-4-Reader和Writer" class="headerlink" title="18.4 Reader和Writer"></a>18.4 Reader和Writer</h2><p>虽然一些原始的流类库不再被使用，但是<code>InputStream</code>和<code>OutputStream</code>在以面向字节形式的I/O中仍可以提供极有价值的功能，<code>Reader</code>和<code>Writer</code>则提供兼容<code>Unicode</code>与面向字符的I/O功能，另外：</p><ol><li>Java 1.1向InputStream和OutputStream继承结构中添加了一些新类，所以这俩类是不会被取代的</li><li>有时我们必须把来自“字节”层次结构中的类和“字符”层次结构中的类结合起来使用。为实现这个目的，要用到“适配器”（adapter）类：<code>InputStreamReader</code>可以把<code>InputStream</code>转换为<code>Reader</code>，而<code>OutPutStreamWriter</code>可以把<code>OutputStream</code>转换为<code>Writer</code>。</li></ol><p>设计<code>Reader</code>和<code>Writer</code>主要是为了国际化。老的I/O继承层次结构仅支持8位字节流，并且不能很好地处理16位的Unicode字符。由于Unicode用于字符国际化，所以添加Reader和Writer继承层次结构就是为了在所有的I/O操作中都支持Unicode。</p><h3 id="18-4-1-数据的来源和去处"><a href="#18-4-1-数据的来源和去处" class="headerlink" title="18.4.1 数据的来源和去处"></a>18.4.1 数据的来源和去处</h3><p>我们应该尽量尝试用Reader和Writer，一旦代码无法成功编译，再考虑用面向字节的类库。</p><p>下表展示了两个继承结构中数据的来源和去处（即数据物理上来自哪里去向哪里）之间的对应关系：</p><table><thead><tr><th style="text-align:left">来源与去处：Java 1.0类</th><th style="text-align:left">相应的Java1.1类</th></tr></thead><tbody><tr><td style="text-align:left">InputStream</td><td style="text-align:left">reader；适配器：InputStreamReader</td></tr><tr><td style="text-align:left">OutputStream</td><td style="text-align:left">Writer；适配器：OutPutStreamWriter</td></tr><tr><td style="text-align:left">FileInputStream</td><td style="text-align:left">FileReader</td></tr><tr><td style="text-align:left">FileOutputStream</td><td style="text-align:left">FileWriter</td></tr><tr><td style="text-align:left">StringBufferInputStream(已弃用)</td><td style="text-align:left">StringReader</td></tr><tr><td style="text-align:left">无</td><td style="text-align:left">StringWriter</td></tr><tr><td style="text-align:left">ByteArrayInputStream</td><td style="text-align:left">CharArrayReader</td></tr><tr><td style="text-align:left">ByteArrayOutputStream</td><td style="text-align:left">CharArrayWriter</td></tr><tr><td style="text-align:left">PipedInputStream</td><td style="text-align:left">PipedReader</td></tr><tr><td style="text-align:left">PipedOutputStream</td><td style="text-align:left">PipedWriter</td></tr></tbody></table><h2 id="18-5-I-O流的典型使用方式"><a href="#18-5-I-O流的典型使用方式" class="headerlink" title="18.5 I/O流的典型使用方式"></a>18.5 I/O流的典型使用方式</h2><h3 id="18-5-1-缓冲输入文件"><a href="#18-5-1-缓冲输入文件" class="headerlink" title="18.5.1 缓冲输入文件"></a>18.5.1 缓冲输入文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓冲输入文件</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(fileName)));</span><br><span class="line">        String s;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> ((s = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(s + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(read(<span class="string">"C:\\think\\test.txt"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello everybody</span><br><span class="line">Today,the rain in Beijing is really big.</span><br></pre></td></tr></table></figure></p><h3 id="18-5-2-从内存输入"><a href="#18-5-2-从内存输入" class="headerlink" title="18.5.2 从内存输入"></a>18.5.2 从内存输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从内存输入</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringReader in = <span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">"C:\\think\\test.txt"</span>));</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) c);<span class="comment">//in.read()以int方式返回下一下一字节，所以要转换为char</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello everybody</span><br><span class="line">Today,the rain in Beijing is really big.</span><br></pre></td></tr></table></figure></p><h3 id="18-5-3-格式化的内存输入"><a href="#18-5-3-格式化的内存输入" class="headerlink" title="18.5.3 格式化的内存输入"></a>18.5.3 格式化的内存输入</h3><p>要读取格式化数据，可以使用<code>DataInputStream</code>，它是面向字节的类（不是面向字符），因此要使用<code>InputStream</code>类而不是<code>Reader</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式化的内存输入</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormattedMemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> ByteArrayInputStream(BufferedInputFile.read(<span class="string">"C:\\think\\test.txt"</span>).getBytes()));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)in.readByte());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"End of stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-5-4-基本的文件输出"><a href="#18-5-4-基本的文件输出" class="headerlink" title="18.5.4 基本的文件输出"></a>18.5.4 基本的文件输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本的文件输出</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFileOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String fileIn = <span class="string">"C:\\think\\test.txt"</span>;</span><br><span class="line">    <span class="keyword">static</span> String fileOut = <span class="string">"C:\\think\\BasicFileOutput.out"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> StringReader(BufferedInputFile.read(fileIn)));</span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(fileOut));</span><br><span class="line">        <span class="keyword">int</span> lineCount = <span class="number">1</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 写入</span></span><br><span class="line">            out.println(lineCount++ + <span class="string">"："</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="comment">// 显示存储的文件</span></span><br><span class="line">        System.out.println(BufferedInputFile.read(fileOut));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：hello everybody</span><br><span class="line">2：Today,the rain in Beijing is really big.</span><br></pre></td></tr></table></figure></p><p><strong>文本文件输出的快捷方式</strong></p><p>Java SE5在<code>PrintWriter</code>中添加了一个辅助构造器，使得不必再每次希望创建文件文件并向其中写入时，都去执行所有的装饰工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文本文件输出的快捷方式</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputShortcut</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String fileIn = <span class="string">"C:\\think\\test.txt"</span>;</span><br><span class="line">    <span class="keyword">static</span> String fileOut = <span class="string">"C:\\think\\FileOutputShortcut.out"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> StringReader(BufferedInputFile.read(fileIn)));</span><br><span class="line">        <span class="comment">// 快捷方式</span></span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(fileOut);</span><br><span class="line">        <span class="keyword">int</span> lineCount = <span class="number">1</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            out.println(lineCount++ + <span class="string">":"</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(BufferedInputFile.read(fileOut));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-5-5-存储和恢复数据"><a href="#18-5-5-存储和恢复数据" class="headerlink" title="18.5.5 存储和恢复数据"></a>18.5.5 存储和恢复数据</h3><p>为了输出可供另一个“流”恢复的数据，我们需要用<code>DataOutputStream</code>写入数据，并用<code>DataInputStream</code>恢复数据，注意<code>DataOutputStream</code>和<code>DataInputStream</code>是面向字节的，因此要使用<code>InputStream</code>和<code>OutPutStream</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储和恢复数据</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoringAndRecoveringData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// store</span></span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"C:\\think\\Data.txt"</span>)));</span><br><span class="line">        out.writeDouble(<span class="number">3.1415926</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"That was pi"</span>);</span><br><span class="line">        out.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"Square root of 2"</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="comment">// recover</span></span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\think\\Data.txt"</span>)));</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3.1415926</span><br><span class="line">That was pi</span><br><span class="line">1.41413</span><br><span class="line">Square root of 2</span><br></pre></td></tr></table></figure></p><p>如果使用<code>DataOutputStream</code>写入数据，Java保证我们可以使用<code>DataInputStream</code>准确地读取数据——无论读和写数据的平台多么不同。</p><p>使用<code>DataOutputStream</code>时，写字符串并且让<code>DataInputStream</code>能够恢复的唯一可靠做法就是使用<code>UTF-8</code>编码。</p><h3 id="18-5-6-读写随机访问文件"><a href="#18-5-6-读写随机访问文件" class="headerlink" title="18.5.6 读写随机访问文件"></a>18.5.6 读写随机访问文件</h3><p>使用<code>RandomAccessFile</code>，利用<code>seek()</code>可以在文件中到处移动，并修改文件中的某个值。使用<code>RandomAccessFile</code>时必须要知道文件排版才能正确地操作，它拥有读取基本类型和UTF-8字符串的各种具体方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取随机访问文件</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandomAccessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"rtest.dat"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Value "</span> + i + <span class="string">"："</span> + rf.readDouble());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(rf.readUTF());</span><br><span class="line">        rf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            rf.writeDouble(i*<span class="number">1.414</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rf.writeUTF(<span class="string">"The end of the file"</span>);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">        rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">        rf.seek(<span class="number">5</span>*<span class="number">8</span>);</span><br><span class="line">        rf.writeDouble(<span class="number">47.0001</span>);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Value 0：0.0</span><br><span class="line">Value 1：1.414</span><br><span class="line">Value 2：2.828</span><br><span class="line">Value 3：4.242</span><br><span class="line">Value 4：5.656</span><br><span class="line">Value 5：7.069999999999999</span><br><span class="line">Value 6：8.484</span><br><span class="line">The end of the file</span><br><span class="line">Value 0：0.0</span><br><span class="line">Value 1：1.414</span><br><span class="line">Value 2：2.828</span><br><span class="line">Value 3：4.242</span><br><span class="line">Value 4：5.656</span><br><span class="line">Value 5：47.0001</span><br><span class="line">Value 6：8.484</span><br><span class="line">The end of the file</span><br></pre></td></tr></table></figure></p><h2 id="18-6-压缩"><a href="#18-6-压缩" class="headerlink" title="18.6 压缩"></a>18.6 压缩</h2><table><thead><tr><th style="text-align:left">压缩类</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">CheckedInputStream</td><td style="text-align:left">GetCheckSum()为任何InputStream产生校验和(不仅是解压缩)</td></tr><tr><td style="text-align:left">CheckedOutputStream</td><td style="text-align:left">GetCheckedSum()为任何OutputStream产生校验和（不仅是压缩）</td></tr><tr><td style="text-align:left">DeflaterOutputStream</td><td style="text-align:left">压缩类的基类</td></tr><tr><td style="text-align:left">ZipOutputStream</td><td style="text-align:left">一个DeflaterOutputStream，用于将数据压缩成Zip文件格式</td></tr><tr><td style="text-align:left">GZIPOutputStream</td><td style="text-align:left">一个DeflaterOutputStream，用于将数据压缩成GZIP文件格式</td></tr><tr><td style="text-align:left">InflaterInputStream</td><td style="text-align:left">解压缩类的基类</td></tr><tr><td style="text-align:left">ZipInputStream</td><td style="text-align:left">一个DeflaterInputStream，用于解压缩Zip文件格式的数据</td></tr><tr><td style="text-align:left">GZIPInputStream</td><td style="text-align:left">一个DeflaterOutputStream，用于解压缩GZIP文件格式的数据</td></tr></tbody></table><p>Zip和GZIP是最常用的压缩算法。</p><h3 id="18-6-1-用GZIP进行简单压缩"><a href="#18-6-1-用GZIP进行简单压缩" class="headerlink" title="18.6.1 用GZIP进行简单压缩"></a>18.6.1 用GZIP进行简单压缩</h3><p>如果想对单个数据流（不是一系列互异数据）进行压缩，GZIP是比较合适的选择，下面是对单个文件进行压缩的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单个文件的GZIP压缩</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPcompress</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"C:\\think\\test.txt"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> GZIPOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"C:\\think\\test.gz"</span>)));</span><br><span class="line">        System.out.println(<span class="string">"Writing file..."</span>);</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(c);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(<span class="string">"Reading file..."</span>);</span><br><span class="line">        BufferedReader in2 = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> GZIPInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\think\\test.gz"</span>))));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = in2.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Writing file...</span><br><span class="line">Reading file...</span><br><span class="line">hello everybody</span><br><span class="line">Today,the rain in Beijing is really big.</span><br></pre></td></tr></table></figure></p><h3 id="18-6-2-用Zip进行多文件保存"><a href="#18-6-2-用Zip进行多文件保存" class="headerlink" title="18.6.2 用Zip进行多文件保存"></a>18.6.2 用Zip进行多文件保存</h3><p>使用<code>Checksum()</code>类来计算和校验文件的检验和，有两种<code>Checksum</code>类型：</p><ol><li>Adler32（比较快）</li><li>CRC32（慢一些，但更准确）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用zip进行多文件保存</span></span><br><span class="line"><span class="comment"> * Created by mrdios on 2016/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zipcompress</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String[] files = <span class="keyword">new</span> String[]&#123;<span class="string">"C:\\think\\BasicFileOutput.out"</span>,<span class="string">"C:\\think\\test.txt"</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.zip"</span>);</span><br><span class="line">        CheckedOutputStream csum = <span class="keyword">new</span> CheckedOutputStream(f, <span class="keyword">new</span> Adler32());</span><br><span class="line">        ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(csum);</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(zos);</span><br><span class="line">        zos.setComment(<span class="string">"A test of java Zipping"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String file: files)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Writing file "</span> + file);</span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">            zos.putNextEntry(<span class="keyword">new</span> ZipEntry(file));</span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">while</span> ((c = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="comment">// 关闭文件流之后才能校验</span></span><br><span class="line">        System.out.println(<span class="string">"Checksum: "</span> + csum.getChecksum().getValue());</span><br><span class="line">        <span class="comment">// 解压文件</span></span><br><span class="line">        System.out.println(<span class="string">"Reading file..."</span>);</span><br><span class="line">        FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"test.zip"</span>);</span><br><span class="line">        CheckedInputStream csumi = <span class="keyword">new</span> CheckedInputStream(fi,<span class="keyword">new</span> Adler32());</span><br><span class="line">        ZipInputStream in2 = <span class="keyword">new</span> ZipInputStream(csumi);</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(in2);</span><br><span class="line">        ZipEntry ze;</span><br><span class="line">        <span class="keyword">while</span> ((ze = in2.getNextEntry()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Reading file "</span> + ze);</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="keyword">while</span> ((x = bis.read()) !=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\nShow entries..."</span>);</span><br><span class="line">        <span class="keyword">if</span> (files.length == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Checksum: "</span> + csumi.getChecksum().getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        ZipFile zf = <span class="keyword">new</span> ZipFile(<span class="string">"test.zip"</span>);</span><br><span class="line">        Enumeration e = zf.entries();</span><br><span class="line">        <span class="keyword">while</span> (e.hasMoreElements())&#123;</span><br><span class="line">            ZipEntry ze2 = (ZipEntry) e.nextElement();</span><br><span class="line">            System.out.println(<span class="string">"File: "</span> + ze2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Writing file C:\think\BasicFileOutput.out</span><br><span class="line">Writing file C:\think\test.txt</span><br><span class="line">Checksum: 3774907338</span><br><span class="line">Reading file...</span><br><span class="line">Reading file C:\think\BasicFileOutput.out</span><br><span class="line">1hello everybody</span><br><span class="line">2Today,the rain in Beijing is really big.</span><br><span class="line">Reading file C:\think\test.txt</span><br><span class="line">hello everybody</span><br><span class="line">Today,the rain in Beijing is really big.</span><br><span class="line">Show entries...</span><br><span class="line">File: C:\think\BasicFileOutput.out</span><br><span class="line">File: C:\think\test.txt</span><br></pre></td></tr></table></figure></p><h3 id="18-6-3-Java档案文件（-jar）"><a href="#18-6-3-Java档案文件（-jar）" class="headerlink" title="18.6.3 Java档案文件（.jar）"></a>18.6.3 Java档案文件（.jar）</h3><p>Sun的JDK自带的jar程序可以根据我们的选择自动压缩文件，可以用命令的形式调用它，如下所示：</p><p>jar [options] destination [manifest] inputfile(s)</p><p>其中<code>options</code>只是一个字母集合（不用输入任何“-”或其他任何标识符）。以下选项字符在Unix和Linux系统中的tar文件中也具有相同的意义，如下所示：</p><table><thead><tr><th style="text-align:left">option</th><th style="text-align:left">desc</th></tr></thead><tbody><tr><td style="text-align:left">c</td><td style="text-align:left">创建一个新的或空的压缩文档</td></tr><tr><td style="text-align:left">t</td><td style="text-align:left">列出目录表</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">解压所有文件</td></tr><tr><td style="text-align:left">x file</td><td style="text-align:left">解压该文件</td></tr><tr><td style="text-align:left">f</td><td style="text-align:left">“我打算指定一个文件名。”如果没用这个选项，jar假设所有的输入都来自于标准输入；或者在创建一个文件时，输出对象也是假设为标准输出</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">表示第一个参数将是用户自建的清单文件的名字</td></tr><tr><td style="text-align:left">v</td><td style="text-align:left">产生详细输出，描述jar所做的工作</td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">只存储文件，不压缩文件（用来创建一个可放在类路径中的JAR文件）</td></tr><tr><td style="text-align:left">M</td><td style="text-align:left">不自动创建文件清单</td></tr></tbody></table><h2 id="18-7-XML"><a href="#18-7-XML" class="headerlink" title="18.7 XML"></a>18.7 XML</h2><p>对象的序列化的一个限制是它只是java的解决方案：只有java程序才能反序列化这种对象。将数据转换为XML格式是另一种更具操作性的解决方案，可以使其被各种各样的平台和语言使用。</p><p>LKZS：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter18;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> nu.xom.Document;</span><br><span class="line"><span class="keyword">import</span> nu.xom.Element;</span><br><span class="line"><span class="keyword">import</span> nu.xom.Serializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xml的使用:对象转换为xml</span></span><br><span class="line"><span class="comment"> * Created by balderdasher on 2016/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String first, last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String first, String last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从person对象产生xml元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Element <span class="title">getXML</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Element person = <span class="keyword">new</span> Element(<span class="string">"person"</span>);</span><br><span class="line">        Element firstName = <span class="keyword">new</span> Element(<span class="string">"first"</span>);</span><br><span class="line">        firstName.appendChild(first);</span><br><span class="line">        Element lastName = <span class="keyword">new</span> Element(<span class="string">"last"</span>);</span><br><span class="line">        lastName.appendChild(last);</span><br><span class="line">        person.appendChild(firstName);</span><br><span class="line">        person.appendChild(lastName);</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Element person)</span> </span>&#123;</span><br><span class="line">        first = person.getFirstChildElement(<span class="string">"first"</span>).getValue();</span><br><span class="line">        last = person.getFirstChildElement(<span class="string">"last"</span>).getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first + <span class="string">" "</span> + last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">format</span><span class="params">(OutputStream os, Document doc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Serializer serializer = <span class="keyword">new</span> Serializer(os, <span class="string">"ISO-8859-1"</span>);</span><br><span class="line">        serializer.setIndent(<span class="number">4</span>);</span><br><span class="line">        serializer.setMaxLength(<span class="number">60</span>);</span><br><span class="line">        serializer.write(doc);</span><br><span class="line">        serializer.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Person&gt; person = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">"Dr.Bunsen"</span>, <span class="string">"Honeydew"</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">"Gonzo"</span>, <span class="string">"The Great"</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">"Phillip"</span>, <span class="string">"Fry"</span>)</span><br><span class="line">        );</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        Element root = <span class="keyword">new</span> Element(<span class="string">"people"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Person p : person) &#123;</span><br><span class="line">            root.appendChild(p.getXML());</span><br><span class="line">        &#125;</span><br><span class="line">        Document doc = <span class="keyword">new</span> Document(root);</span><br><span class="line">        format(System.out, doc);</span><br><span class="line">        format(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"People.xml"</span>)), doc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">people</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">first</span>&gt;</span>Dr.Bunsen<span class="tag">&lt;/<span class="name">first</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">last</span>&gt;</span>Honeydew<span class="tag">&lt;/<span class="name">last</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">first</span>&gt;</span>Gonzo<span class="tag">&lt;/<span class="name">first</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">last</span>&gt;</span>The Great<span class="tag">&lt;/<span class="name">last</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">first</span>&gt;</span>Phillip<span class="tag">&lt;/<span class="name">first</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">last</span>&gt;</span>Fry<span class="tag">&lt;/<span class="name">last</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">people</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从xml中反序列化对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter18;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> nu.xom.Builder;</span><br><span class="line"><span class="keyword">import</span> nu.xom.Document;</span><br><span class="line"><span class="keyword">import</span> nu.xom.Elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从xml中反序列化对象</span></span><br><span class="line"><span class="comment"> * Created by balderdasher on 2016/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Document doc = <span class="keyword">new</span> Builder().build(fileName);</span><br><span class="line">        Elements elements = doc.getRootElement().getChildElements();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;elements.size();i++)&#123;</span><br><span class="line">            add(<span class="keyword">new</span> Person(elements.get(i)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        People p = <span class="keyword">new</span> People(<span class="string">"People.xml"</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Dr.Bunsen Honeydew, Gonzo The Great, Phillip Fry]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;18-1-File类&quot;&gt;&lt;a href=&quot;#18-1-File类&quot; class=&quot;headerlink&quot; title=&quot;18.1 File类&quot;&gt;&lt;/a&gt;18.1 File类&lt;/h2&gt;&lt;p&gt;File类是一个实用类库工具，可以帮助我们处理文件目录问题。File（文件）类既能代表一个特定文件的&lt;em&gt;名称&lt;/em&gt;，又能代表一个目录下的一组文件的名称。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://balderdasher.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://balderdasher.github.io/tags/java/"/>
    
      <category term="读书笔记" scheme="https://balderdasher.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="io" scheme="https://balderdasher.github.io/tags/io/"/>
    
  </entry>
  
</feed>
